<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Understanding ELFs, part 3</title><meta content="Understanding ELFs, part 3" name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/posts/understanding_elfs_3/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content="Understanding ELFs, part 3" property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/posts/understanding_elfs_3/ property=twitter:url><meta content="Understanding ELFs, part 3" property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/posts/understanding_elfs_3/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>understanding_elfs_3</span></div><time datetime=2025-01-30>Published on: <span class=accent-data>2025-01-30</span></time><address rel=author>By <span class=accent-data> InnocentZero, and exploiitm </span></address><h1>Understanding ELFs, part 3</h1><h2 id=on-relocations-loading-binaries-and-more>On relocations, loading binaries, and more</h2><p>The reason we need relocations is because of a simple fact, the existence of shared libraries.<p>One question anyone may ask is the necessity of having shared libraries. That is done to avoid repitition of pages in memory, a thing which was critical in older days because of low memory. Another thing to note is that there is separation of the library and the binary. The library can be updated without updating the binary as such.<p>This is dealt with by using <em>relocation sections</em>. These contain the info needed to do the relocation of the symbol within the binary’s context. The section usually links to an additional section where the relocation is going to happen.<p>There are two ways in which object files may be linked: statically and dynamically.<p>Static linking is fairly straightforward, the linker takes in all the object files and archive files (=libc.a=) and creates a single self-contained binary containing all the required functionality. This is done at the end of compilation itself.<p>Dynamic linking is a slightly more complex and involved process. It defers the linking part from compile time to runtime. The binary contains the information about its choice of runtime linker (also referred to as an <em>interpreter</em>) and the dynamic symbols and how to obtain them.<h2 id=loading-an-elf-on-the-memory>Loading an ELF on the memory</h2><p>The system first executes the file’s “interpreter” before handing over execution to the binary. Over here, the interpreter is obtained from the <code>.interp</code> section in the <code>PT_INTERP</code> segment in memory. This can be read using <code>readelf -p .interp example</code>.<pre style=background:#282828;color:#fdf4c1aa><code><span>$ readelf -p .interp example
</span><span>
</span><span>String dump of section '.interp':
</span><span>  [     0]  /lib64/ld-linux-x86-64.so.2
</span></code></pre><p>The interpreter loads the binary into memory first.<p>The interpreter sets up the environment using the <code>.dynamic</code> section of the binary. This can be seen using <code>readelf -d executable</code>.<p>In this, the interpreter will recursively begin visiting all the <strong>NEEDED</strong> dynamic libraries to be loaded into memory. For each dependency, the following steps are executed:<ul><li>The ELF is mapped into memory.<li>Relocations are performed, in the original binary we patch all the absolute addresses and resolve references to other object files.<li>Its dynamic table is parsed and dependencies loaded.<li>Run <code>dl_init</code>, which executes all the functions from <code>INIT</code>, and <code>INIT_ARRAY</code> for the just loaded libraries.</ul><p>Now the control is handed over to <code>_start</code> in the ELF binary. That gets the pointer to <code>_dl_fini</code> in <code>rdx</code>. This prepares the stack with a few arguments and calls <code>_libc_start_main</code>.<p><code>_libc_start_main</code> receives a function pointer to <code>main</code>, <code>init</code>, <code>fini</code>, and <code>rtld_fini</code> (this is the same as <code>dl_fini</code>).<p>This function has a bunch of things going on, such as setting up of thread local storage and such. Here we only care about two things:<ul><li><p><code>__cxa_atexit__</code> which sets up <code>_dl_fini</code> as the destructor after the program is done.</p><li><p>A call to <code>call_init</code> that run the constructors in the <code>INIT</code> and <code>INIT_ARRAY</code> dynamic table entries. Note that <code>dl_init</code> was for the entries in the shared libraries themselves, but this is for the binary.</p><li><p>Finally, control after this is handed over to <code>main</code>.</p><li><p>Immediately after <code>main</code>, <code>exit</code> is called. This only transfers the control to <code>__run_exit_handlers</code>.</p><li><p>This runs all the functions registered in <code>__exit_funcs</code> which also contains <code>_dl_fini</code>.</p></ul><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>