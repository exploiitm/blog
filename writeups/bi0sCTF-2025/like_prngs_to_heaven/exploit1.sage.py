

# This file was *autogenerated* from the file exploit1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_32 = Integer(32); _sage_const_624 = Integer(624); _sage_const_397 = Integer(397); _sage_const_31 = Integer(31); _sage_const_0x9908B0DF = Integer(0x9908B0DF); _sage_const_11 = Integer(11); _sage_const_0xFFFFFFFF = Integer(0xFFFFFFFF); _sage_const_7 = Integer(7); _sage_const_0x9D2C5680 = Integer(0x9D2C5680); _sage_const_15 = Integer(15); _sage_const_0xEFC60000 = Integer(0xEFC60000); _sage_const_18 = Integer(18); _sage_const_1 = Integer(1); _sage_const_0x80000000 = Integer(0x80000000); _sage_const_51 = Integer(51); _sage_const_69069 = Integer(69069); _sage_const_16 = Integer(16); _sage_const_374 = Integer(374); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_0 = Integer(0); _sage_const_24 = Integer(24); _sage_const_0xFF = Integer(0xFF); _sage_const_2 = Integer(2); _sage_const_224 = Integer(224); _sage_const_192 = Integer(192); _sage_const_160 = Integer(160); _sage_const_8 = Integer(8); _sage_const_152 = Integer(152); _sage_const_75 = Integer(75); _sage_const_0xFFF = Integer(0xFFF); _sage_const_33 = Integer(33); _sage_const_0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 = Integer(0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141); _sage_const_148 = Integer(148); _sage_const_21 = Integer(21); _sage_const_108 = Integer(108); _sage_const_107 = Integer(107); _sage_const_69 = Integer(69); _sage_const_30 = Integer(30); _sage_const_232 = Integer(232); _sage_const_200 = Integer(200); _sage_const_83 = Integer(83); _sage_const_45 = Integer(45)#
# This script must be run within a SageMath environment (`sage exploit.sage`)
#
import subprocess
import json
import ast
from tqdm import trange
from hashlib import sha256
import sys # Import sys to find the correct python executable

# SageMath imports
from sage.all import *

# Z3 imports for reversing PRNGs
from z3 import *

# Local file imports
from RMT import R_MT19937_32bit as R_mt
# from secret import FLAG # Not needed for exploit, only for server

# --- FINAL FIX: Load ALL required toolkits from the reference writeup ---
# This avoids any errors in manual lattice construction.
load("https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/common/babai_cvp.sage")
load("https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/problems/hidden_number_problem.sage")
load("https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/attacks/ecdsa_key_disclosure.sage")


# --- Z3 Solver Classes and Functions ---

class BreakerRipley32:
    """
    Z3 solver for 32-bit Mersenne Twister with Ripley seeding.
    This class models the RMT's seeding process to find the original seed.
    """
    def __init__(self):
        (self.w, self.n, self.m, self.r) = (_sage_const_32 , _sage_const_624 , _sage_const_397 , _sage_const_31 )
        self.a = _sage_const_0x9908B0DF 
        (self.u, self.d) = (_sage_const_11 , _sage_const_0xFFFFFFFF )
        (self.s, self.b) = (_sage_const_7 , _sage_const_0x9D2C5680 )
        (self.t, self.c) = (_sage_const_15 , _sage_const_0xEFC60000 )
        self.l = _sage_const_18 
        self.lower_mask = (_sage_const_1  << self.r) - _sage_const_1 
        self.upper_mask = _sage_const_0x80000000 

    def tamper_state(self, y):
        """Models the tempering function of the MT."""
        # Using Sage's unambiguous XOR operator ^^
        y = y ^ (LShR(y, self.u))
        y = y ^ ((y << self.s) & self.b)
        y = y ^ ((y << self.t) & self.c)
        y = y ^ LShR(y, self.l)
        return y

    def twist_state(self, MT):
        """Models the twist function of the MT."""
        n, m, a = self.n, self.m, self.a
        lower_mask, upper_mask = self.lower_mask, self.upper_mask
        new_MT = [BitVec(f"MT_twisted_{i}", _sage_const_32 ) for i in range(n)]
        for i in range(n):
            x = (MT[i] & upper_mask) + (MT[(i + _sage_const_1 ) % n] & lower_mask)
            xA = LShR(x, _sage_const_1 )
            # Using Sage's unambiguous XOR operator ^^
            xA = If(x & _sage_const_1  == _sage_const_1 , xA ^ a, xA)
            new_MT[i] = simplify(MT[(i + m) % n] ^ xA)
        return new_MT

    def get_seed_mt(self, outputs):
        """Solves for the original seed given observed outputs."""
        n = self.n
        SEED = BitVec('seed', _sage_const_32 )
        MT = [BitVec(f"MT_init_{i}", _sage_const_32 ) for i in range(n)]

        # Model the weak Ripley seeding process
        num = SEED
        for _ in range(_sage_const_51 ):
            num = _sage_const_69069  * num + _sage_const_1 

        g_prev = num
        constraints = []
        for i in range(n):
            g = _sage_const_69069  * g_prev + _sage_const_1 
            constraints.append(MT[i] == (g & _sage_const_0xFFFFFFFF ))
            g_prev = g

        MT_twisted = self.twist_state(MT)

        S = Solver()
        S.add(constraints)

        for idx, value in outputs:
            S.add(self.tamper_state(MT_twisted[idx]) == value)

        if S.check() == sat:
            model = S.model()
            return model[SEED].as_long()
        else:
            print("[-] Could not solve for RMT seed.")
            return None

def partial_nonce_breaker(_and, equation):
    """Solves for the 'benjamin' values using the leaked clues."""
    term = BitVec('term', _sage_const_32 )
    # Using Sage's unambiguous XOR operator ^^
    res = term ^ ((term << _sage_const_16 ) & _and)
    S = Solver()
    S.add(res == equation)
    if S.check() == sat:
        model = S.model()
        return model[term].as_long()
    else:
        print("[-] Could not solve for benjamin value.")
        return None

def decrypt_flag(d, ciphertext, iv):
    """Derives the AES key from the private key and decrypts the flag."""
    from Crypto.Cipher import AES
    from Crypto.Util.Padding import unpad

    ciphertext = bytes.fromhex(ciphertext)
    iv = bytes.fromhex(iv)
    sha2 = sha256()
    sha2.update(str(d).encode('ascii'))
    key = sha2.digest()[:_sage_const_16 ]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext)
    return unpad(plaintext, _sage_const_16 ).decode()

# --- Process Interaction ---
# Use sys.executable to ensure the subprocess uses the same Python interpreter
python_executable = sys.executable
process = subprocess.Popen([python_executable, '-u', './chall.py'],
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           text=True)

def read_until_prompt(proc, prompt_text="Expecting Routine in JSON format: "):
    output = ""
    while prompt_text not in output:
        char = proc.stdout.read(_sage_const_1 )
        if not char:
            break
        output += char
    return output

def send_command(proc, command_dict):
    payload = json.dumps(command_dict) + '\n'
    proc.stdin.write(payload)
    proc.stdin.flush()

# --- Main Exploit Logic ---
try:
    print("[+] Starting exploit...")

    # 1. Decay the supreme_RNG
    num_restarts = _sage_const_374 
    print(f"[+] Stage 1: Decaying supreme_RNG by restarting level {num_restarts} times...")
    read_until_prompt(process)
    for _ in trange(num_restarts, desc="Restarting"):
        send_command(process, {"event": "level_restart"})
        read_until_prompt(process)
    print("[+] supreme_RNG decayed to zero.")

    # 2. Heal HP and get RMT outputs from the deadcoin minigame
    print("\n[+] Stage 2: Playing deadcoin to heal HP and get RMT outputs...")
    rmt_outputs = []
    for i in range(_sage_const_3 ):
        send_command(process, {"event": "perform_deadcoin"})
        read_until_prompt(process, prompt_text="Action code: ")
        process.stdin.write('0\n')
        process.stdin.flush()
        output = read_until_prompt(process)
        
        blood_id_line = None
        for line in output.split('\n'):
            if "BLOOD" in line and "ID:" in line:
                blood_id_line = line
                break
        
        if not blood_id_line:
            print("[-] Error: Could not find 'BLOOD - ID:' in server output. The deadcoin game may have failed.")
            print("[-] Server output received:")
            print(output)
            process.kill()
            exit()
            
        blood_id = int(blood_id_line.split(': ')[_sage_const_1 ])
        rmt_outputs.append((i, blood_id))
        print(f"    -> Got RMT output {i+_sage_const_1 }: {blood_id}")
    print("[+] HP is now 160. Got 3 RMT outputs.")

    # 3. Recover the RMT seed
    print("\n[+] Stage 3: Reversing RMT to find the seed...")
    breaker = BreakerRipley32()
    recovered_seed = breaker.get_seed_mt(rmt_outputs)
    if recovered_seed is None:
        print("[-] Exploit failed. Could not recover RMT seed.")
        process.kill()
        exit()
    print(f"[+] Recovered RMT seed: {recovered_seed}")
    local_rmt = R_mt(recovered_seed)
    for _ in range(_sage_const_3 ):
        local_rmt.get_num()

    # 4. Collect 5 signatures and reconstruct nonce parts
    print("\n[+] Stage 4: Collecting 5 signatures and reconstructing nonces...")
    signatures_r = []
    signatures_s = []
    k_known_list = []
    msg_to_sign = b"V1 is going down"
    num_signatures = _sage_const_5 

    for i in trange(num_signatures, desc="Signing"):
        send_command(process, {"event": "call_the_signer"})
        read_until_prompt(process, prompt_text="What do you wish to speak? ")
        process.stdin.write(msg_to_sign.decode() + '\n')
        process.stdin.flush()

        output = read_until_prompt(process)
        
        sign_res_line = None
        for line in output.split('\n'):
            if "'r':" in line and "'s':" in line:
                sign_res_line = line
                break
        
        if not sign_res_line:
            print("[-] Error: Could not find signature data in server output.")
            print("[-] Server output received:")
            print(output)
            process.kill()
            exit()
            
        sign_res = ast.literal_eval(sign_res_line)
        signatures_r.append(sign_res['r'])
        signatures_s.append(sign_res['s'])

        n_gen_const = sign_res['nonce_gen_consts']
        b1 = partial_nonce_breaker(n_gen_const[_sage_const_0 ][_sage_const_0 ], n_gen_const[_sage_const_0 ][_sage_const_1 ])
        b2 = partial_nonce_breaker(n_gen_const[_sage_const_1 ][_sage_const_0 ], n_gen_const[_sage_const_1 ][_sage_const_1 ])

        cycles = sign_res['heat_gen']
        for _ in range(cycles[_sage_const_0 ]):
            local_rmt.get_num()
        k_val = local_rmt.get_num()

        for _ in range(cycles[_sage_const_1 ]):
            local_rmt.get_num()
        _k_val = local_rmt.get_num()

        k_bar = (
            (b1 >> _sage_const_24  & _sage_const_0xFF ) * _sage_const_2 **_sage_const_224  +
            (b1 >> _sage_const_16  & _sage_const_0xFF ) * _sage_const_2 **_sage_const_192  +
            k_val * _sage_const_2 **_sage_const_160  +
            (b1 >> _sage_const_8  & _sage_const_0xFF ) * _sage_const_2 **_sage_const_152  +
            (b1 & _sage_const_0xFF ) * _sage_const_2 **_sage_const_75  +
            (b2 >> _sage_const_24  & _sage_const_0xFFF ) * _sage_const_2 **_sage_const_33  +
            _k_val
        )
        k_known_list.append(k_bar)

    print("[+] Collected all necessary signature data.")

    # 5. Setup and solve the EHNP with the lbc_toolkit
    print("\n[+] Stage 5: Setting up and solving the EHNP with lbc_toolkit...")

    n = _sage_const_0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 
    zi = sha256()
    zi.update(msg_to_sign)
    Z = [int(zi.hexdigest(),_sage_const_16 ) for _ in range(num_signatures)]

    # Known part of private key is 0 after decay
    xbar = _sage_const_0 
    
    # Parameters for the unknowns, taken from reference writeup
    Pi = [_sage_const_148 , _sage_const_21 ] 
    Nu = [_sage_const_108 , _sage_const_107 ]
    Mu = [[_sage_const_24 , _sage_const_24 , _sage_const_69 , _sage_const_30 ] for _ in range(num_signatures)]
    lambdha = [[_sage_const_232 , _sage_const_200 , _sage_const_83 , _sage_const_45 ] for _ in range(num_signatures)]

    # Call the solver from the loaded toolkit
    recovered_d = ecdsa_key_disclosure(xbar, n, Z, signatures_r, signatures_s, k_known_list, Pi, Nu, lambdha, Mu)
    
    if recovered_d == _sage_const_0 :
        print("[-] lbc_toolkit failed to recover the key.")
        process.kill()
        exit()
        
    print(f"[+] Private key recovered: {recovered_d}")

    # 6. Get and decrypt the flag
    print("\n[+] Stage 6: Getting and decrypting the flag...")
    send_command(process, {"event": "get_encrypted_flag"})
    output = read_until_prompt(process)
    
    flag_data_line = None
    for line in output.split('\n'):
        if "'ciphertext':" in line:
            flag_data_line = line
            break

    if not flag_data_line:
        print("[-] Error: Could not find flag data in server output.")
        process.kill()
        exit()
        
    flag_data = ast.literal_eval(flag_data_line)

    ciphertext = flag_data["ciphertext"]
    iv = flag_data["iv"]

    flag = decrypt_flag(recovered_d, ciphertext, iv)
    print(f"\n[+] FLAG: {flag}")

except Exception as e:
    print(f"\n[-] An unexpected error occurred: {e}")
    print("[-] Reading stderr from child process to find the error:")
    stdout, stderr = process.communicate()
    print("--- STDOUT ---")
    print(stdout)
    print("--- STDERR ---")
    print(stderr)
    print("----------------")
finally:
    # Cleanup
    if process.poll() is None:
        process.kill()

