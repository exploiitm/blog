<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Like PRNGs to Heaven</title><meta content="Like PRNGs to Heaven" name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/like_prngs_to_heaven/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content="Like PRNGs to Heaven" property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/like_prngs_to_heaven/ property=twitter:url><meta content="Like PRNGs to Heaven" property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/like_prngs_to_heaven/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>like_prngs_to_heaven</span></div><time datetime=2025-07-10>Published on: <span class=accent-data>2025-07-10</span></time><address rel=author>By <span class=accent-data> Sanat, and exploiitm </span></address><h1>Like PRNGs to Heaven</h1><h1></h1><h2 id=challenge-overview>Challenge Overview</h2><p>Our aim in this challenge is to interact with a game system that presents us with several options:<ul><li><code>get_encrypted_flag</code> - Retrieves the encrypted flag (<strong>costs 50 HP</strong>)<li><code>perform_deadcoin</code> - Play a minigame to gain HP (<strong>+20 HP if successful, no cost</strong>)<li><code>call_the_signer</code> - Get an ECDSA signature for a message (<strong>costs 20 HP</strong>)<li><code>level_restart</code> - Restart the level (<strong>resets HP to 100, no cost</strong>)<li><code>level_quit</code> - Exit the game</ul><p>The challenge revolves around ECDSA signatures based on Elliptic Curve Cryptography. For a comprehensive understanding of ECDSA, refer to this excellent video: <a href="https://www.youtube.com/watch?v=NF1pwjL9-DE" rel=noopener target=_blank>here</a><h2 id=vulnerabilities-analysis>Vulnerabilities Analysis</h2><p>There are numerous vulnerabilities across all the challenge files:<h3 id=1-weak-rmt-mersenne-twister-implementation-rmt-py>1. Weak RMT (Mersenne Twister) Implementation - RMT.py</h3><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>seedMT</span><span>(</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>seed</span><span>):
</span><span>    num </span><span style=color:#fe8019>= </span><span>seed
</span><span>    </span><span style=color:#fdf4c1>self</span><span>.index </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self</span><span>.n
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_ </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>51</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        num </span><span style=color:#fe8019>= </span><span style=color:#d3869b>69069 </span><span style=color:#fe8019>* </span><span>num </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>1
</span><span>    g_prev </span><span style=color:#fe8019>= </span><span>num
</span><span>    </span><span style=color:#fa5c4b>for </span><span>i </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(self.n)</span><span>:
</span><span>        g </span><span style=color:#fe8019>= </span><span style=color:#d3869b>69069 </span><span style=color:#fe8019>* </span><span>g_prev </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>1
</span><span>        </span><span style=color:#fdf4c1>self</span><span>.</span><span style=color:#fdf4c1>MT</span><span>[i] </span><span style=color:#fe8019>= </span><span>g </span><span style=color:#fe8019>& </span><span style=color:#fdf4c1>self</span><span>.d
</span><span>        g_prev </span><span style=color:#fe8019>= </span><span>g
</span></code></pre><p>This implementation uses a weak seeding algorithm (Ripley’s seeding) that generates the entire 624-word initial state from a single 32-bit seed. The twist() and tempering operations are mathematically reversible if we have enough consecutive outputs from get_num().<h3 id=2-flawed-supreme-rng-chall-py>2. Flawed supreme_RNG - chall.py</h3><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>@</span><span style=color:#fabd2f>staticmethod
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>supreme_RNG</span><span>(</span><span style=color:#fdf4c1>seed</span><span>: </span><span style=color:#fabd2f>int</span><span>, </span><span style=color:#fdf4c1>length</span><span>: </span><span style=color:#fabd2f>int </span><span style=color:#fe8019>= </span><span style=color:#d3869b>10</span><span>):
</span><span>    </span><span style=color:#fa5c4b>while </span><span style=color:#d3869b>True</span><span>:
</span><span>        str_seed </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(seed) </span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(</span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(seed)) </span><span style=color:#fe8019>% </span><span style=color:#d3869b>2 </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span style=color:#fa5c4b>else </span><span style=color:#b8bb26>'0' </span><span style=color:#fe8019>+ </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(seed)
</span><span>        sqn </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(seed</span><span style=color:#fe8019>**</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>)
</span><span>        mid </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(str_seed) </span><span style=color:#fe8019>>> </span><span style=color:#d3869b>1
</span><span>        start </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(sqn) </span><span style=color:#fe8019>>> </span><span style=color:#d3869b>1</span><span>) </span><span style=color:#fe8019>- </span><span>mid
</span><span>        end </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(sqn) </span><span style=color:#fe8019>>> </span><span style=color:#d3869b>1</span><span>) </span><span style=color:#fe8019>+ </span><span>mid   
</span><span>        </span><span style=color:#fa5c4b>yield </span><span>sqn[start : end]</span><span style=color:#fdf4c1>.zfill(length)
</span><span>        seed </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(sqn[start : end])
</span></code></pre><p>This middle-square method is completely deterministic and predictable. The seed is derived from:<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fdf4c1>CORE </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0xb4587f9bd72e39c54d77b252f96890f2347ceff5cb6231dfaadb94336df08dfd
</span><span>RNG_seed </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>simple_lcg(CORE)
</span></code></pre><h3 id=3-nonce-generation-leaks-full-noncense-gen>3. Nonce Generation Leaks - full_noncense_gen()</h3><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>full_noncense_gen</span><span>(</span><span style=color:#fdf4c1>self</span><span>) -> </span><span style=color:#fabd2f>tuple</span><span>:
</span><span>    k_, cycle_1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.sec_real_bits(</span><span style=color:#d3869b>32</span><span style=color:#fdf4c1>)
</span><span>    _k, cycle_2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.sec_real_bits(</span><span style=color:#d3869b>32</span><span style=color:#fdf4c1>)
</span><span>
</span><span>    benjamin1, and1, eq1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.partial_noncense_gen(</span><span style=color:#d3869b>32</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span>    benjamin2, and2, eq2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.partial_noncense_gen(</span><span style=color:#d3869b>32 </span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>16 </span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span></code></pre><p>The function returns:<pre style=background:#282828;color:#fdf4c1aa><code><span>n1 = [and1, eq1] and n2 = [and2, eq2]  # Info about benjamin values
</span><span>cycles = [cycle_1, cycle_2]            # Heat cycles revealing RMT advancement
</span></code></pre><p>This leaks substantial information about the nonce structure, particularly the benjamin1 and benjamin2 values which can be recovered using the equation:<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>equation </span><span style=color:#fe8019>= </span><span>term </span><span style=color:#fe8019>^ </span><span>((term </span><span style=color:#fe8019><< </span><span>shift) </span><span style=color:#fe8019>& </span><span>_and)
</span></code></pre><h3 id=4-ecdsa-signature-information>4. ECDSA Signature Information</h3><p>The sign function returns:<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>return </span><span>(r, s, n1, n2, cycles)
</span></code></pre><p>The ECDSA signature equation is:<p>$s = k^{-1} \cdot (H(m) + r \cdot d) \mod n$<p>Where:<ul><li><code>s</code>: The signature value<li><code>k</code>: The nonce (ephemeral private key)<li><code>H(m)</code>: SHA256 hash of the message<li><code>r</code>: x-coordinate of the point kG<li><code>d</code>: The private key<li><code>n</code>: Order of the elliptic curve (secp256k1)</ul><h2 id=the-exploit>The Exploit</h2><h3 id=step-1-decay-supreme-rng-to-zero>Step 1: Decay supreme_RNG to Zero</h3><p>Through experimentation, we discover that after exactly 374 restarts, the supreme_RNG yields “0000000000”. This happens because the middle-square method eventually converges to zero:<h3 id=step-2-exploit-the-deadcoin-game>Step 2: Exploit the Deadcoin Game</h3><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>feedbacker_parry </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(</span><span style=color:#fabd2f>next</span><span style=color:#fdf4c1>(self.n_gen))  </span><span style=font-style:italic;color:#928374># = 0
</span><span>style_bonus </span><span style=color:#fe8019>= </span><span>feedbacker_parry </span><span style=color:#fe8019>^ </span><span>(feedbacker_parry </span><span style=color:#fe8019>>> </span><span style=color:#d3869b>5</span><span>)  </span><span style=font-style:italic;color:#928374># = 0 ^ 0 = 0
</span><span>power </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>pow</span><span style=color:#fdf4c1>(base, style_bonus, speed)  </span><span style=font-style:italic;color:#928374># = 2^0 mod speed = 1
</span></code></pre><p>When we see power = 1, we know the answer is 0. Playing deadcoin three times with answer “0” gives us:<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>blood </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.Max_Sec.get_num()  </span><span style=font-style:italic;color:#928374># RMT output
</span></code></pre><p>These three consecutive RMT outputs allow us to reverse the seed.<h3 id=step-3-reverse-rmt-seed-with-z3>Step 3: Reverse RMT Seed with Z3</h3><p>Using Z3 solver, we model:<ul><li>An unknown 32-bit seed<li>The Ripley seeding process to generate initial state<li>The twist operation<li>The tempering function</ul><p>We constrain the first three outputs to match our collected BLOOD_IDs and solve for the seed.<h3 id=step-4-recover-partial-nonces>Step 4: Recover Partial Nonces</h3><p>With the RMT seed recovered, we can predict future outputs. For each signature, we:<ul><li>Use the heat cycles to advance our local RMT appropriately<li>We recover <code>k_</code> and <code>_k</code> values from RMT<li>Use Z3 to solve for benjamin values from the leaked equations</ul><h3 id=step-5-extended-hidden-number-problem-ehnp>Step 5: Extended Hidden Number Problem (EHNP)</h3><p>Now we have partial information about both the private key and nonces. Following Joseph Surin’s paper <a href=https://eprint.iacr.org/2023/032.pdf rel=noopener target=_blank>here</a>, we apply the Extended Hidden Number Problem algorithm.<p><strong>ECDSA-EHNP Equation Setup</strong><p>Start with:<p>$s[i] \cdot k[i] \equiv H(m) + r[i] \cdot d \pmod{n}$<p>Rearranged:<p>$-r[i] \cdot d + s[i] \cdot k[i] \equiv H(m) \pmod{n}$<p>Known structures:<p>$d = 2^{148} \cdot d_1 + 2^{21} \cdot d_2$<p>$k[i] = k_{bar} + 2^{232} \cdot k_1 + 2^{200} \cdot k_2 + 2^{83} \cdot k_3 + 2^{45} \cdot k_4$<p>Substitute:<p>$-r[i](2^{148} \cdot d_1 + 2^{21} \cdot d_2) + s[i](2^{232} \cdot k_1 + 2^{200} \cdot k_2 + 2^{83} \cdot k_3 + 2^{45} \cdot k_4) \equiv H(m) - s[i] \cdot k_{bar} \pmod{n}$<p>EHNP form:<p>$\alpha_i \cdot \sum 2^{\pi_j} \cdot x_j + \sum \rho_{i,j} \cdot k_{i,j} \equiv \beta_i - \alpha_i \cdot \bar{x} \pmod{p}$<p>We will now outsource these values to an external solver, coz why not :p We will use <code>ecdsa_key_disclosure()</code> from Joseph Surin’s toolkit to solve.<h3 id=step-6-recover-the-flag>Step 6: Recover the Flag</h3><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>sha2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>sha256()
</span><span style=color:#fdf4c1>sha2.update(</span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(d).encode(</span><span style=color:#b8bb26>'ascii'</span><span style=color:#fdf4c1>))
</span><span>key </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>sha2.digest()</span><span>[:</span><span style=color:#d3869b>16</span><span>]
</span><span>cipher </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>AES.new(key, AES.MODE_CBC, iv)
</span><span>plaintext </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>cipher.decrypt(ciphertext)
</span></code></pre><p><strong>FLAG:</strong> <code>bi0sCTF{p4rry_7h15_y0u_f1l7hy_w4r_m4ch1n3}</code><hr><h2 id=key-takeaways>Key Takeaways</h2><ul><li>The importance of proper PRNG seeding<li>The power of lattice-based attacks on cryptographic systems</ul><p>Reference:<a href=https://blog.bi0s.in/2025/06/13/Crypto/Elliptic-Curves/LikePRNGStoHeaven-bi0sCTF2025/ rel=noopener target=_blank>here</a><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>