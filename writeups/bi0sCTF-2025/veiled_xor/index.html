<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>veiled_xor</title><meta content=veiled_xor name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/veiled_xor/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content=veiled_xor property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/veiled_xor/ property=twitter:url><meta content=veiled_xor property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/veiled_xor/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>veiled_xor</span></div><time datetime=2025-07-07>Published on: <span class=accent-data>2025-07-07</span></time><address rel=author>By <span class=accent-data> Sanat, and exploiitm </span></address><h1>veiled_xor</h1><h1 id=challenge-veiled-xor>Challenge: veiled_xor</h1><h2 id=challenge-overview>Challenge Overview</h2><p>We are given the following parameters for an RSA encryption:<ul><li>RSA modulus <code>n</code><li>Ciphertext <code>c</code><li>An additional mysterious value: <code>veiled_xor</code></ul><p>The challenge states that <code>n = p * q</code> and <code>veiled_xor = p ^ rev_q</code>, where:<ul><li><code>p</code> and <code>q</code> are 1024-bit primes.<li><code>rev_q</code> is the bitwise reversal of <code>q</code>.</ul><p>The goal is to recover the prime factors <code>p</code> and <code>q</code> to decrypt the ciphertext.<h2 id=vulnerability>Vulnerability</h2><p>The core vulnerability is the leakage of information through the <code>veiled_xor</code> value. This value creates a direct mathematical relationship between the bits of <code>p</code> and the reversed bits of <code>q</code>, which we can exploit to reconstruct the primes.<h2 id=strategy-smart-bit-by-bit-construction>Strategy: Smart Bit-by-Bit Construction</h2><p>A brute-force attack is infeasible given the 1024-bit key size. Instead, we will be constructing the primes bit-by-bit from both ends simultaneously.<p>At each step <code>k</code> (from <code>k=1</code> to <code>k=511</code>), we determine the bits at position <code>k</code> (from the LSB side) and <code>1023-k</code> (from the MSB side) for both <code>p</code> and <code>q</code>.<ul><li><strong><code>p_base</code>, <code>q_base</code>:</strong> These represent the partially constructed primes at the beginning of a step. All unknown middle bits are treated as zero.<li><strong>Candidates:</strong> We maintain a list of all <code>(p, q)</code> pairs that remain plausible after each stepâ€™s filtering.</ul><h2 id=implementation-exploit-c>Implementation: <code>exploit.c</code></h2><p>The logic is implemented in C to leverage its speed for bitwise operations and the GMP library for handling large numbers. The multi-threaded approach allows us to check the expanding list of candidates efficiently.<h3 id=the-core-loop-derivation-and-filtering>The Core Loop: Derivation and Filtering</h3><p>Instead of naively trying all 16 combinations for the four new bits (<code>p[k]</code>, <code>q[k]</code>, <code>p[1023-k]</code>, <code>q[1023-k]</code>) at each step, we use an algebraic shortcut to reduce the possibilities to just <strong>two</strong>.<h4 id=1-derivation-logic-thread-worker-optimized>1. Derivation Logic (<code>thread_worker_optimized</code>)</h4><p>For each candidate <code>(p_base, q_base)</code> from the previous step, we combine two fundamental equations:<p><strong>Equation A (from <code>n = p * q</code>):</strong> The <code>k</code>-th bit of the product <code>n</code> is the XOR sum of the <code>k</code>-th bits of the inputs and the final carry bit from the lower positions.<blockquote><p><code>n[k] = p[k] ^ q[k] ^ carry_k</code></blockquote><p><strong>Equation B (from <code>veiled_xor</code>):</strong> The <code>k</code>-th bit of <code>p</code> is related to the <code>(1023-k)</code>-th bit of <code>q</code>.<blockquote><p><code>p[k] = veiled_xor[k] ^ q[1023-k]</code></blockquote><p>By substituting Equation B into Equation A, we can solve for a direct relationship between the two unknown <code>q</code> bits:<p><code>n[k] = (veiled_xor[k] ^ q[1023-k]) ^ q[k] ^ carry_k</code><p>Rearranging this gives us our magic formula:<p><code>q[k] ^ q[1023-k] = n[k] ^ veiled_xor[k] ^ carry_k</code><p>The <code>carry_k</code> term is the <code>k</code>-th bit of the product of the parts we already know: <code>prod = p_base * q_base</code>.<p>So, we define a target value: <code>target_q_xor = n[k] ^ prod[k] ^ veiled_xor[k]</code><p>This gives us the final relationship: <code>q[1023-k] = q[k] ^ target_q_xor</code><h4 id=2-generating-the-two-candidates>2. Generating the Two Candidates</h4><p>This relationship means we only have two scenarios to test for each <code>(p_base, q_base)</code>:<ol><li><strong>Guess <code>q[k] = 0</code>:</strong> This forces <code>q[1023-k] = target_q_xor</code>.<li><strong>Guess <code>q[k] = 1</code>:</strong> This forces <code>q[1023-k] = 1 ^ target_q_xor</code>.</ol><p>Once we have a pair of <code>q</code> bits, we can instantly find the corresponding <code>p</code> bits using the <code>veiled_xor</code> leak again:<ul><li><code>p[k] = veiled_xor[k] ^ q[1023-k]</code><li><code>p[1023-k] = veiled_xor[1023-k] ^ q[k]</code></ul><p>We now have a complete set of four new bits, which we add to <code>p_base</code> and <code>q_base</code> to form a new candidate pair <code>(p_new, q_new)</code>.<h4 id=3-the-msb-filter>3. The MSB Filter</h4><p>For each of the two new candidate pairs, we apply a crucial filter to discard impossible paths:<ol><li><strong>Top Bits Check:</strong> The product of the most significant bits of our candidate (<code>top_prod</code>) must not exceed the most significant bits of the real <code>n</code> (<code>top_n</code>).<li><strong>Carry Margin:</strong> The difference (<code>top_n - top_prod</code>) is due to carries from the unknown middle. This difference must be within a plausible bound: <code>diff < 2^(k+2)</code>.</ol><p>If a <code>(p_new, q_new)</code> pair passes this filter, it is added to the list of candidates for the next iteration.<h3 id=final-verification-and-decryption>Final Verification and Decryption</h3><p>After the loop completes at <code>k=511</code>, we are left with several plausible, fully-formed candidate pairs. We then perform a final, exact check:<ol><li>Loop through every surviving candidate <code>(p, q)</code>.<li>Check if <code>p * q</code> is <strong>exactly equal</strong> to <code>n</code>.<li>Check if <code>p ^ rev_q</code> is <strong>exactly equal</strong> to <code>veiled_xor</code>.</ol><p>Only one candidate will satisfy both conditions. Once we find this correct pair:<ul><li>We compute the private key: <code>d = inverse(e, (p-1)*(q-1))</code><li>We decrypt the ciphertext: <code>m = pow(c, d, n)</code><li>We convert the resulting message <code>m</code> from an integer to a string to reveal the flag.</ul><p><strong>Flag:</strong> <code>bi0sCTF{X0rcery_R3ve3rsing_1s_4n_4rt_2d3e3d}</code><p><em>Reference: <a href=https://github.com/toby-bro/Writeups/blob/main/bi0sCTF2025/veiled_xor/ rel=noopener target=_blank>here</a></em><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>