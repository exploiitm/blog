#include <gmp.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define PRIME_BITS 1024

// --- Global Variables ---
mpz_t n, c, veiled_xor;

// --- Data Structures ---
typedef struct {
    mpz_t p;
    mpz_t q;
} pq_pair;

typedef struct {
    pq_pair *data;
    size_t size;
    size_t capacity;
} pq_array;

typedef struct {
    int thread_id;
    size_t start_idx;
    size_t end_idx;
    pq_array *input_candidates;
    pq_array *output_candidates;
    size_t k;
    pthread_mutex_t *output_mutex;
} thread_data_t;

// --- Array Management ---
void pq_array_init(pq_array *arr, size_t initial_capacity) {
    arr->size = 0;
    arr->capacity = initial_capacity > 0 ? initial_capacity : 16;
    arr->data = malloc(arr->capacity * sizeof(pq_pair));
    if (!arr->data) {
        perror("malloc failed");
        exit(EXIT_FAILURE);
    }
}

void pq_array_clear(pq_array *arr) {
    for (size_t i = 0; i < arr->size; ++i) {
        mpz_clears(arr->data[i].p, arr->data[i].q, NULL);
    }
    free(arr->data);
    arr->data = NULL;
    arr->size = 0;
    arr->capacity = 0;
}

void pq_array_push_safe(pq_array *arr, const mpz_t p, const mpz_t q, pthread_mutex_t *mutex) {
    pthread_mutex_lock(mutex);
    if (arr->size >= arr->capacity) {
        arr->capacity = (arr->capacity == 0) ? 16 : arr->capacity * 2;
        arr->data = realloc(arr->data, arr->capacity * sizeof(pq_pair));
        if (!arr->data) {
            perror("realloc failed");
            exit(EXIT_FAILURE);
        }
    }
    mpz_init_set(arr->data[arr->size].p, p);
    mpz_init_set(arr->data[arr->size].q, q);
    arr->size++;
    pthread_mutex_unlock(mutex);
}

// --- GMP and Logic Helpers ---
void import_globals() {
    mpz_inits(n, c, veiled_xor, NULL);
    mpz_set_str(n, "25650993834245004720946189793874326497984795849338302417110946799293291648040249066481025511053012034073848003478136002015789778483853455736405270138192685004206122168607287667373629714589814547144217162436740164024414206705483947822707673759856022882063396271521077034396144039740088690783163935477234001508676877728359035563304374705319120303835098697559771353065115371216095633826663393222290375210498159025443467666369652776698531368926392564476840557482790175694984871271075976052162527476586777386578254654222259777299785563550342986250558793337690540798983389913689337683350216697595855274995968459458553148267", 10);
    mpz_set_str(c, "7874419222145223100478995004906732383469089972173454594282476506666095078687712494332749473566534625352139353593310707008146533254390514332880136585545606758108380402050369451711762195058199249765633645224407166178729834108159734540770902813439688437621416030538050164358987313607945402928893945400086827254622507315341530235984071126104731692679123171962413857123065243252313290356908958113679070546907527095194888688858140118665219670816655147095649132221436351529029926610142793850463533766705147562234382644751744682744799743855986811769162311342911946128543115444104102909314075691320520722623778914052878038508", 10);
    mpz_set_str(veiled_xor, "26845073698882094013214557201710791833291706601384082712658811014034994099681783926930272036664572532136049856667171349310624166258134687815795133386046337514685147643316723034719743474088423205525505355817639924602251866472741277968741560579392242642848932606998045419509860412262320853772858267058490738386", 10);
}

void reverse_bits_in_mpz(mpz_t result, const mpz_t input) {
    mpz_set_ui(result, 0);
    for (size_t i = 0; i < PRIME_BITS; i++) {
        if (mpz_tstbit(input, i)) {
            mpz_setbit(result, PRIME_BITS - 1 - i);
        }
    }
}

void* thread_worker_optimized(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    size_t k = data->k;

    mpz_t p_base, q_base, prod, p_new, q_new;
    mpz_t top_n, top_prod, diff, bound;

    mpz_inits(p_base, q_base, prod, p_new, q_new, NULL);
    mpz_inits(top_n, top_prod, diff, bound, NULL);

    for (size_t i = data->start_idx; i < data->end_idx; ++i) {
        mpz_set(p_base, data->input_candidates->data[i].p);
        mpz_set(q_base, data->input_candidates->data[i].q);

        mpz_mul(prod, p_base, q_base);
        int target_q_xor = mpz_tstbit(n, k) ^ mpz_tstbit(prod, k) ^ mpz_tstbit(veiled_xor, k);

        for (int q_k_cand = 0; q_k_cand <= 1; ++q_k_cand) {
            int q_msb_cand = q_k_cand ^ target_q_xor;
            int p_k_cand = mpz_tstbit(veiled_xor, k) ^ q_msb_cand;
            int p_msb_cand = mpz_tstbit(veiled_xor, PRIME_BITS - 1 - k) ^ q_k_cand;

            mpz_set(p_new, p_base);
            mpz_set(q_new, q_base);

            if (p_k_cand) mpz_setbit(p_new, k);
            if (q_k_cand) mpz_setbit(q_new, k);
            if (p_msb_cand) mpz_setbit(p_new, PRIME_BITS - 1 - k);
            if (q_msb_cand) mpz_setbit(q_new, PRIME_BITS - 1 - k);

            mpz_tdiv_q_2exp(top_n, n, 2 * PRIME_BITS - 2 * (k + 1));
            mpz_mul(prod, p_new, q_new);
            mpz_tdiv_q_2exp(top_prod, prod, 2 * PRIME_BITS - 2 * (k + 1));
            
            if (mpz_cmp(top_prod, top_n) <= 0) {
                mpz_sub(diff, top_n, top_prod);
                mpz_set_ui(bound, 1);
                mpz_mul_2exp(bound, bound, k + 2);
                if (mpz_cmp(diff, bound) < 0) {
                    pq_array_push_safe(data->output_candidates, p_new, q_new, data->output_mutex);
                }
            }
        }
    }
    mpz_clears(p_base, q_base, prod, p_new, q_new, NULL);
    mpz_clears(top_n, top_prod, diff, bound, NULL);
    return NULL;
}

int main() {
    import_globals();
    
    pq_array candidates;
    pq_array_init(&candidates, 1);
    
    mpz_t p_init, q_init;
    mpz_inits(p_init, q_init, NULL);
    mpz_setbit(p_init, 0); mpz_setbit(p_init, PRIME_BITS - 1);
    mpz_setbit(q_init, 0); mpz_setbit(q_init, PRIME_BITS - 1);
    
    pthread_mutex_t initial_mutex = PTHREAD_MUTEX_INITIALIZER;
    pq_array_push_safe(&candidates, p_init, q_init, &initial_mutex);
    pthread_mutex_destroy(&initial_mutex);
    mpz_clears(p_init, q_init, NULL);

    int num_threads = sysconf(_SC_NPROCESSORS_ONLN);
    printf("Using %d threads for processing.\n\n", num_threads);

    for (size_t k = 1; k < PRIME_BITS / 2; ++k) {
        pq_array next_candidates;
        pq_array_init(&next_candidates, candidates.size * 2);
        printf("[k=%zu] Expanding %zu candidates...\n", k, candidates.size);

        if (candidates.size == 0) {
            printf("Search failed, no more candidates.\n");
            pq_array_clear(&next_candidates);
            break;
        }

        pthread_t* threads = malloc(num_threads * sizeof(pthread_t));
        thread_data_t* thread_data = malloc(num_threads * sizeof(thread_data_t));
        pthread_mutex_t output_mutex = PTHREAD_MUTEX_INITIALIZER;

        size_t candidates_per_thread = candidates.size / num_threads;
        size_t remainder = candidates.size % num_threads;
        size_t current_start_idx = 0;

        for(int i = 0; i < num_threads; ++i) {
            size_t batch_size = candidates_per_thread + (i < remainder ? 1 : 0);
            thread_data[i].start_idx = current_start_idx;
            thread_data[i].end_idx = current_start_idx + batch_size;
            current_start_idx += batch_size;
            thread_data[i].input_candidates = &candidates;
            thread_data[i].output_candidates = &next_candidates;
            thread_data[i].k = k;
            thread_data[i].output_mutex = &output_mutex;
            
            if (batch_size > 0) {
                pthread_create(&threads[i], NULL, thread_worker_optimized, &thread_data[i]);
            }
        }
        
        for(int i = 0; i < num_threads; ++i) {
            if (thread_data[i].start_idx < thread_data[i].end_idx) {
               pthread_join(threads[i], NULL);
            }
        }
        
        pthread_mutex_destroy(&output_mutex);
        free(threads);
        free(thread_data);
        
        pq_array_clear(&candidates);
        candidates = next_candidates;

        printf("[k=%zu] Found %zu new candidates.\n\n", k, candidates.size);
    }
    
    printf("\nReached %d bits - performing final complete factorization check...\n", PRIME_BITS / 2);
    printf("Performing final verification of %zu candidates...\n", candidates.size);
    
    mpz_t p_final, q_final, temp_n, temp_v, rev_q;
    mpz_inits(p_final, q_final, temp_n, temp_v, rev_q, NULL);
    int found = 0;

    for (size_t i = 0; i < candidates.size; ++i) {
        mpz_mul(temp_n, candidates.data[i].p, candidates.data[i].q);
        if (mpz_cmp(temp_n, n) == 0) {
            reverse_bits_in_mpz(rev_q, candidates.data[i].q);
            mpz_xor(temp_v, candidates.data[i].p, rev_q);
            if (mpz_cmp(temp_v, veiled_xor) == 0) {
                printf("\nFound valid complete factorization!\n");
                printf("Candidate %zu satisfies both p*q=n and p^reverse(q)=veil_xor\n", i);
                mpz_set(p_final, candidates.data[i].p);
                mpz_set(q_final, candidates.data[i].q);
                found = 1;
                break;
            }
        }
    }

    if (found) {
        gmp_printf("\nFound factors:\np = %Zd\n", p_final);
        gmp_printf("q = %Zd\n", q_final);

        printf("\n--- Decrypting Flag ---\n");
        mpz_t phi, d, m, e_mpz, p_m1, q_m1;
        mpz_inits(phi, d, m, e_mpz, p_m1, q_m1, NULL);
        mpz_set_ui(e_mpz, 65537);
        mpz_sub_ui(p_m1, p_final, 1);
        mpz_sub_ui(q_m1, q_final, 1);
        mpz_mul(phi, p_m1, q_m1);
        mpz_invert(d, e_mpz, phi);
        mpz_powm(m, c, d, n);

        // Corrected flag printing logic
        size_t size;
        char* raw_bytes = (char*)mpz_export(NULL, &size, 1, 1, 0, 0, m);
        
        // The decrypted message is the flag itself, no padding to search for.
        // We create a null-terminated string to be safe for printf.
        char* flag_str = (char*)malloc(size + 1);
        if (flag_str) {
            memcpy(flag_str, raw_bytes, size);
            flag_str[size] = '\0'; // Null-terminate the string
            printf("\nFLAG: %s\n", flag_str);
            free(flag_str);
        } else {
            perror("malloc for flag string failed");
        }
        free(raw_bytes);

        mpz_clears(phi, d, m, e_mpz, p_m1, q_m1, NULL);
    } else {
        printf("\nCould not find valid factors among the candidates.\n");
    }
    
    pq_array_clear(&candidates);
    mpz_clears(n, c, veiled_xor, p_final, q_final, temp_n, temp_v, rev_q, NULL);
    return 0;
}
