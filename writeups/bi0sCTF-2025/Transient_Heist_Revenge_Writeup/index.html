<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Transient Heist Revenge</title><meta content="Transient Heist Revenge" name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/Transient_Heist_Revenge_Writeup/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content="Transient Heist Revenge" property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/Transient_Heist_Revenge_Writeup/ property=twitter:url><meta content="Transient Heist Revenge" property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/bi0sCTF-2025/Transient_Heist_Revenge_Writeup/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>Transient_Heist_Revenge_Writeup</span></div><time datetime=2025-07-15>Published on: <span class=accent-data>2025-07-15</span></time><address rel=author>By <span class=accent-data> Vrishab, and exploiitm </span></address><h1>Transient Heist Revenge</h1><h2 id=overview>Overview</h2><p>The main goal of the challenge is to trick the function <code>isSolved</code> from Setup.sol into completing. There are 2 main entities here:<ul><li><strong>Bank Vault</strong> (USDSEngine): This is a very secure vault that stores collateral and allows minting of USDS stablecoin. It uses transient storage (tstore/tload) to verify only the correct Bi0sSwapPair can call certain functions.<li><strong>Currency Exchange</strong> (Bi0sSwapPair): This booth swaps one type of token for another.</ul><p>We need to trick the Vault into thinking we’ve deposited a huge amount as collateral - it has to be more than a very large hash value.<h2 id=how-collateral-deposits-work>How Collateral Deposits Work</h2><p>Collateral Deposits normally work like this:<ol><li>A user calls <code>depositCollateralThroughSwap</code> to deposit collateral via an automated token swap.<li>The vault transfers tokens to the Bi0sSwapPair, writes the swap pair’s address into transient storage (<code>tstore(1, bi0sSwapPair)</code>).<li>The swap is performed, and upon completion, the Bi0sSwapPair calls back into <code>bi0sSwapv1Call</code> to deposit the collateral.<li>In <code>bi0sSwapv1Call</code>, the vault checks that <code>msg.sender</code> matches the stored address from transient storage, ensures the requested collateral deposit is not greater than the amount of tokens received (<code>collateralDepositAmount <= amountOut</code>), and updates internal collateral balances.</ol><h2 id=the-vulnerability>The Vulnerability</h2><p>Now, the only check on who can call <code>bi0sSwapv1Call</code> is the transient storage slot. This means that if an attacker can use the value written into transient storage, they can then call <code>bi0sSwapv1Call</code> from their own contract address. The vault only checks <code>msg.sender == tload(1)</code>, but <code>tload(1)</code> gets overwritten during the callback with <code>tokensSentToUserVault</code>, allowing us to control this value.<h2 id=exploit-steps>Exploit Steps</h2><p><strong>1. Deploying a malicious contract at a controlled address</strong> - we use CREATE2 to deploy an attacker contract at an address that can be precomputed. This contract must implement the <code>bi0sSwapv1Call</code> function. A contract is used instead of a normal wallet since only contracts can call <code>bi0sSwapv1Call</code> and pass the transient storage check while being deployed at a known address. We should ensure we get a contract address with sufficient leading zeros for the arithmetic manipulation.<p><strong>2. Initiating a Legitimate Swap</strong> - we now call <code>depositCollateralThroughSwap</code> with 80,000 WETH which we want to swap for SafeMoon. This triggers <code>tstore(1, bi0sSwapPair)</code> - usage of transient storage which survives for the entire transaction, not just the swap call.<p><strong>3. Overwrite Transient Storage During First Callback</strong>: During the legitimate <code>bi0sSwapv1Call</code> callback, we set <code>collateralDepositAmount = amountOut - vanity_contract_address</code>, making <code>tokensSentToUserVault = vanity_contract_address</code>. The line <code>tstore(1, tokensSentToUserVault)</code> then overwrites the original swap pair address with our contract address.<p><strong>4. Second Call to bi0sSwapv1Call</strong>: Within the same transaction, we call <code>bi0sSwapv1Call</code> directly from our vanity contract. The check <code>msg.sender == tload(1)</code> now passes because <code>tload(1)</code> contains our contract address from step 3.<p><strong>5. Set Arbitrary Collateral Amounts</strong>: In the second call, we can supply ANY <code>amountOut</code> and <code>collateralDepositAmount > FLAG_HASH</code> (ensuring <code>collateralDepositAmount <= amountOut</code>). These don’t need to be realistic token amounts - just arbitrary large numbers.<p><strong>6. Repeat for Second Token</strong>: The <code>isSolved()</code> function requires BOTH <code>collateralTokens[0]</code> (WETH) AND <code>collateralTokens[1]</code> (SafeMoon) to exceed <code>FLAG_HASH</code>. Since transient storage persists for the entire transaction, you can make a second direct call to <code>bi0sSwapv1Call</code> with the other token type using the same poisoned transient storage.<h2 id=arithmetic-manipulation-used>Arithmetic Manipulation Used</h2><p>The exploit requires careful calculation: <code>tokensSentToUserVault = amountOut - collateralDepositAmount</code> must equal the vanity contract address. We need a vanity address with 7+ leading zeros to make this arithmetic feasible compared to <code>FLAG_HASH</code>.<h2 id=why-the-vanity-address-matters>Why the Vanity Address Matters</h2><ul><li>We need a contract deployed at a <strong>small numeric address</strong> (7 leading zeros) to make the arithmetic work.<li>The calculation <code>tokensSentToUserVault = amountOut - collateralDepositAmount</code> must equal our contract address.<li>We need an address comparatively smaller than <code>FLAG_HASH</code> so that in the first callback, <code>amountOut = vanityAddress + smallCollateralAmount</code> is achievable through legitimate token swaps, while in the second call you can use <code>collateralDepositAmount > FLAG_HASH</code>.<li>This address then gets written to transient storage, allowing our contract to <strong>pass the <code>msg.sender</code> check</strong> on the second call.</ul><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>