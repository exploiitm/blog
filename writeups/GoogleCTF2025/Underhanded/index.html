<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Underhanded</title><meta content=Underhanded name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Underhanded/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content=Underhanded property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Underhanded/ property=twitter:url><meta content=Underhanded property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Underhanded/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>Underhanded</span></div><time datetime=2025-07-23>Published on: <span class=accent-data>2025-07-23</span></time><address rel=author>By <span class=accent-data> Swaminath Shiju, and exploiitm </span></address><h1>Underhanded</h1><h1 id=underhanded-gctf25>Underhanded GCTF25</h1><h3 id=description>Description</h3><p>Proudly sharing our Python implementation of AES. By the way, we sneakily hid a backdoor. Can you see sharp and see what went wrong?<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>challenge</span><span>():
</span><span>    k </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>os.urandom(</span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)
</span><span>    aes </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>AES(k)
</span><span>
</span><span>    </span><span style=font-style:italic;color:#928374># I will encrypt FIVE messages for you, that's it.
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_ </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>5</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        m </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>.fromhex(</span><span style=color:#fabd2f>input</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'üìÑ '</span><span style=color:#fdf4c1>))
</span><span>        c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>aes.encrypt(m)
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'ü§´'</span><span style=color:#fdf4c1>, c.hex())
</span><span>
</span><span>    _k </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>.fromhex(</span><span style=color:#fabd2f>input</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'üîë '</span><span style=color:#fdf4c1>))
</span><span>    </span><span style=color:#fa5c4b>if </span><span>k </span><span style=color:#fe8019>!= </span><span>_k: </span><span style=color:#fa5c4b>raise </span><span style=color:#fabd2f>Exception</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'incorrect guess!'</span><span style=color:#fdf4c1>)
</span></code></pre><h3 id=solution>Solution</h3><p>Here the gist of the question is to guess the custom AES‚Äôs key from 5 chosen plaintext ciphers 16 times. Now we need to hunt for backdoors in the AES implementation.<p>Looking into the encrypt function<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>encrypt</span><span>(</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>m</span><span>: </span><span style=color:#fabd2f>bytes</span><span>) -> </span><span style=color:#fabd2f>bytes</span><span>:
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>bytearray</span><span style=color:#fdf4c1>(m)
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.add_round_key(c, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)
</span><span>    </span><span style=color:#fa5c4b>for </span><span>r </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, self.n_rounds)</span><span>:
</span><span>        c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.sub_bytes(c)
</span><span>        c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.shift_rows(c)
</span><span>        c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.mix_columns(c)
</span><span>        c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.add_round_key(c, r)
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.sub_bytes(c)
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.shift_rows(c)
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>self.add_round_key(c, self.n_rounds)
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fabd2f>bytes</span><span style=color:#fdf4c1>(c)
</span></code></pre><p>this seems pretty normal, but when we look into <code>shift_rows</code> the first statement looks like it has a ‚Äútypo‚Äù.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>shift_rows</span><span>(</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>m</span><span>: </span><span style=color:#fabd2f>bytearray</span><span>) -> </span><span style=color:#fabd2f>bytearray</span><span>:
</span><span>    m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>4</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>8</span><span>], m[</span><span style=color:#d3869b>12</span><span>] </span><span style=color:#fe8019>= </span><span>m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>4</span><span>], m[</span><span style=color:#fe8019>-</span><span style=color:#d3869b>8</span><span>], m[</span><span style=color:#d3869b>12</span><span>]
</span><span>    m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>5</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>9</span><span>], m[</span><span style=color:#d3869b>13</span><span>] </span><span style=color:#fe8019>= </span><span>m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>5</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>9</span><span>], m[</span><span style=color:#d3869b>13</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>]
</span><span>    m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>6</span><span>], m[</span><span style=color:#d3869b>10</span><span>], m[</span><span style=color:#d3869b>14</span><span>] </span><span style=color:#fe8019>= </span><span>m[</span><span style=color:#d3869b>10</span><span>], m[</span><span style=color:#d3869b>14</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>6</span><span>]
</span><span>    m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>7</span><span>], m[</span><span style=color:#d3869b>11</span><span>], m[</span><span style=color:#d3869b>15</span><span>] </span><span style=color:#fe8019>= </span><span>m[</span><span style=color:#d3869b>15</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span>], m[</span><span style=color:#fe8019>+</span><span style=color:#d3869b>7</span><span>], m[</span><span style=color:#d3869b>11</span><span>]
</span><span>    </span><span style=color:#fa5c4b>return </span><span>m
</span></code></pre><p>That <code>m[-8]</code> is supposed to be a <code>m[+8]</code>. Another backdoor is simply how multiple blocks of plaintext (i.e length of PT > 16). For instance looking at shift rows it clearly operates, uses only the first 16 bytes (other than <code>m[-8]</code> of course).<p>The same is true for <code>mix_columns</code> as well.<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>mix_columns</span><span>(</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>m</span><span>: </span><span style=color:#fabd2f>bytearray</span><span>) -> </span><span style=color:#fabd2f>bytearray</span><span>:
</span><span>    </span><span style=color:#fa5c4b>for </span><span>i </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>4</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        t </span><span style=color:#fe8019>= </span><span>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span>] </span><span style=color:#fe8019>^ </span><span>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>^ </span><span>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span>] </span><span style=color:#fe8019>^ </span><span>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span>]
</span><span>        u </span><span style=color:#fe8019>= </span><span>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span>]
</span><span>        m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span>] </span><span style=color:#fe8019>^= </span><span>t </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>xtime(m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>] </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>])
</span><span>        m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span>] </span><span style=color:#fe8019>^= </span><span>t </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>xtime(m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>] </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>])
</span><span>        m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span>] </span><span style=color:#fe8019>^= </span><span>t </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>xtime(m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>] </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span style=color:#fdf4c1>])
</span><span>        m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span>] </span><span style=color:#fe8019>^= </span><span>t </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>xtime(m[i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>3</span><span style=color:#fdf4c1>] </span><span style=color:#fe8019>^ </span><span style=color:#fdf4c1>u)
</span><span>    </span><span style=color:#fa5c4b>return </span><span>m
</span></code></pre><p>So if we send multiple blocks, every block other than the first one is only affected by <code>add_round_key</code> and <code>sub_bytes</code>.<p>Now we can bring both of them together to create an exploit. Denoting resulting cipher text as $c_0, c_1,\cdots$, the input to the last shift rows as $s_0,s_1,\cdots$ and the keys using $k_0,k_1,\cdots$. Now looking at how we use the <code>m[-8]</code> to exploit the last <code>add_round_key</code>. <code>r = (n-8)%16</code><p>$$ \begin{aligned} c_8&=s_r\oplus k_{10}[8] \ c_r&=s_r\oplus k_{10}[r] \ \ \ c_r\oplus c_8 &=k_{10}[8]\oplus k_{10}[r] \end{aligned} $$ Here $n$ is the total plaintext length. This gives us 5 relations for the bytes in $k_{10}$. So if we guess a value for $k_{10}[8]$ that gives us 6 bytes in $k_{10}$.<p>Now we can try to reverse the key-scheduling to get more bytes in the other round keys. We have multiple possible choices for these 6 bytes I chose <code>0, 4, 5, 8, 9, 13</code> bytes. Now looking at the relevant parts of the key scheduling algorithm.<p>$$ \begin{aligned} k_{n}[0]&=k_{n-1}[0]\oplus \sigma(k_{n-1}[13])\oplus \text{RCON}[n-1][0]\ \ \ k_{n}[4]&=k_{n-1}[4]\oplus k_{n}[0]\ \ \ k_{n}[5]&=k_{n-1}[5]\oplus k_{n}[1]\ \ \ k_{n}[8]&=k_{n-1}[8]\oplus k_{n}[4]\ \ \ k_{n}[9]&=k_{n-1}[9]\oplus k_{n}[5]\ \ \ k_{n}[13]&=k_{n-1}[13]\oplus k_{n}[9] \end{aligned} $$<p>Here $\text {RCON}$ is an array of constants. So if we have $k_{10}[0]$,$k_{10}[4]$,$k_{10}[5]$,$k_{10}[8]$,$k_{10}[9]$,$k_{10}[13]$ we can derive $k_9[0]$,$k_9[4]$,$k_9[8]$,$k_9[9]$,$k_9[13]$. We clearly lose a byte but as we keep going backward we get.<table><thead><tr><th><th style=text-align:center>0<th style=text-align:center>4<th style=text-align:center>5<th style=text-align:center>8<th style=text-align:center>9<th style=text-align:center>13<tbody><tr><td>10<td style=text-align:center>$k_{10}[0]$<td style=text-align:center>$k_{10}[4]$<td style=text-align:center>$k_{10}[5]$<td style=text-align:center>$k_{10}[8]$<td style=text-align:center>$k_{10}[9]$<td style=text-align:center>$k_{10}[13]$<tr><td>9<td style=text-align:center>$k_{9}[0]$<td style=text-align:center>$k_{9}[4]$<td style=text-align:center><td style=text-align:center>$k_{9}[8]$<td style=text-align:center>$k_{9}[9]$<td style=text-align:center>$k_{9}[13]$<tr><td>8<td style=text-align:center>$k_{8}[0]$<td style=text-align:center>$k_{8}[4]$<td style=text-align:center><td style=text-align:center>$k_{8}[8]$<td style=text-align:center><td style=text-align:center>$k_{8}[13]$<tr><td>7<td style=text-align:center><td style=text-align:center>$k_{7}[4]$<td style=text-align:center><td style=text-align:center>$k_{7}[8]$<td style=text-align:center><td style=text-align:center><tr><td>6<td style=text-align:center><td style=text-align:center><td style=text-align:center><td style=text-align:center>$k_{6}[8]$<td style=text-align:center><td style=text-align:center></table><p>Now we look at the byte xor‚Äôed with $k_j[8]$ in a later block denote it by C. Then $$ C=k_{10}[8]\oplus\sigma(k_9[8]\oplus \sigma(k_8[8]\cdots\sigma(k_0[8]\oplus P))) $$<p>we can move the known bytes to the left hand side since $\sigma$ and $\oplus$ are reversible.<p>$$ C‚Äô=k_{5}[8]\oplus\sigma(k_4[8]\oplus \sigma(k_3[8]\cdots\sigma(k_0[8]\oplus P))) $$ The naive brute force now would need $2^8 \times 2^{8\times 6}=2^{56}$ guesses (1 byte for $k_{10}$ and then 6 bytes from the previous round keys).<p>However we can be clever here, since they are reversible we can rewrite it as.<p>$$ \sigma^{-1}(\sigma^{-1}(\sigma^{-1}(C‚Äô\oplus k_5[8])\oplus k_4[8])\oplus k_3[8]) = k_2[8]\oplus \sigma(k_1[8]\oplus\sigma(k_0[0]\oplus P)) $$ Now we can brute force each side separately using a meet in the middle attack needing is more feasible. We can shorten the time some more by leveraging more information from the CT.<p>If we look at another byte xor‚Äôd with $k_j[8]$ we get a similar equation<p>$$ \sigma^{-1}(\sigma^{-1}(\sigma^{-1}(C‚Äô‚Äò\oplus k_5[8])\oplus k_4[8])\oplus k_3[8]) = k_2[8]\oplus \sigma(k_1[8]\oplus\sigma(k_0[0]\oplus P‚Äô)) $$ Xor-ing both we get<p>$$ \begin{aligned} \sigma^{-1}(\sigma^{-1}(\sigma^{-1}(C‚Äô\oplus k_5[8])\oplus k_4[8])\oplus k_3[8]) \oplus \sigma^{-1}(\sigma^{-1}(\sigma^{-1}(C‚Äô‚Äò\oplus k_5[8])\oplus k_4[8])\oplus k_3[8]) = \ \sigma(k_1[8]\oplus\sigma(k_0[0]\oplus P‚Äô)) \oplus \sigma(k_1[8]\oplus\sigma(k_0[0]\oplus P)) \end{aligned} $$<p>This eliminated a variable without minimal impact in check time but almost halfs number of iterations required.<p>Now with the entire $k_j[8]$ and $k_{10}[4]$ known we can derive $k_j[4]$ and then $k_j[0]$, $k_j[13]$, $k_j[9]$ and $k_j[5]$. Now we need to guess a byte 10 times for the remaining bytes which are easily doable guesses to get all the remaining key bytes.<blockquote><p>Note: You need a sufficiently beefy computer to do this 16 times in 300s</blockquote><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>