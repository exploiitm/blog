<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>FILTERMAZE</title><meta content=FILTERMAZE name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Filtermaze/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content=FILTERMAZE property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Filtermaze/ property=twitter:url><meta content=FILTERMAZE property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/Filtermaze/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>Filtermaze</span></div><time datetime=2025-08-14>Published on: <span class=accent-data>2025-08-14</span></time><address rel=author>By <span class=accent-data> Vibhu Mehrotra, and exploiitm </span></address><h1>FILTERMAZE</h1><h2 id=summary>Summary</h2><p>The problem has two parts: 1.A maze 2.A mathematical equation, with an error term which hides a secret matrix s<p>On solving the maze, we get the magnitudes of the error matrix. Now, that along with a few mathematical manipulations we can solve for s directly.<h2 id=solution>Solution:</h2><ul><li>The maze itself can be bruteforced. We can input incomplete paths and check if it is along the correct path. So, we can solve it in O(n^2) , and since the maze has a total of around 20 nodes, its very feasible.</ul><p>Lets study the second section<p>Code Explanation<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>LWEParams</span><span>:
</span><span>  lwe_n: </span><span style=color:#fabd2f>int </span><span style=color:#fe8019>= </span><span style=color:#d3869b>50
</span><span>  lwe_m: </span><span style=color:#fabd2f>int </span><span style=color:#fe8019>= </span><span style=color:#d3869b>100
</span><span>  lwe_q: </span><span style=color:#fabd2f>int </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1009
</span><span>  A: List[</span><span style=color:#fabd2f>int</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>field(init</span><span style=color:#fe8019>=</span><span style=color:#d3869b>False</span><span style=color:#fdf4c1>)
</span><span>  s: List[</span><span style=color:#fabd2f>int</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>field(init</span><span style=color:#fe8019>=</span><span style=color:#d3869b>False</span><span style=color:#fdf4c1>)
</span><span>  e: List[</span><span style=color:#fabd2f>int</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>field(init</span><span style=color:#fe8019>=</span><span style=color:#d3869b>False</span><span style=color:#fdf4c1>)
</span><span>  b: List[</span><span style=color:#fabd2f>int</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>field(init</span><span style=color:#fe8019>=</span><span style=color:#d3869b>False</span><span style=color:#fdf4c1>)
</span><span>  
</span></code></pre><p>@dataclass class LWEParams: Defines default parameters for an LWE (Learning With Errors) problem:<ul><li><p>lwe_n: secret vector length (50)</p><li><p>lwe_m: number of equations (100)</p><li><p>lwe_q: modulus (1009)</p></ul><p>A, s, e, b: will store the public matrix, secret vector, error vector, and result vector respectively (set later).<ul><li><p><strong>post_init</strong> After initialization, generates lwe_error_range, a list of random error magnitudes in [0, q), one for each equation.</p><li><p>load_graph(filepath) Reads a JSON graph file from disk, converts string keys to integers, and returns it.</p><li><p>load_flag(filepath) Reads the first line of a file (the flag), strips newline characters, and returns it.</p><li><p>create_lwe_instance_with_error(…) Generates a random LWE instance:</p></ul><p>s: random secret vector of length n, randbelow(q): [0,q) range.<p>A: random <strong>public</strong> matrix of size m × n with entries in [0, q).<p>e: error vector whose entries are either +mag or -mag from error_mags.<p>b: computed as (A @ s + e) mod q, the standard LWE equation. Returns (A, s, e, b) as lists for further use. <strong>(public)</strong><h3 id=how-do-we-solve-this>How do we solve this?</h3><p>Bruteforcing of the maze finally gives us the magnitude of e. we can run it through this function which uses the following math to get the signs: $$A @ s + e = b mod q$$ $$A @ s - b = e mod q$$ $$e*-1 (A @ s - b) = sign mod q$$<pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>find_signs</span><span>(</span><span style=color:#fdf4c1>A</span><span>, </span><span style=color:#fdf4c1>b</span><span>, </span><span style=color:#fdf4c1>mags</span><span>):
</span><span>  basis </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Matrix(A).augment(Matrix(b).T)
</span><span>  basis_ </span><span style=color:#fe8019>= </span><span>[]
</span><span>  </span><span style=color:#fa5c4b>for </span><span>i, row </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>enumerate</span><span style=color:#fdf4c1>(basis.rows())</span><span>:
</span><span>    </span><span style=color:#fdf4c1>basis_.append(</span><span style=color:#fabd2f>pow</span><span style=color:#fdf4c1>(mags[i], </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, q) </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>row)
</span><span>
</span><span>
</span><span>  basis </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Matrix(basis_).augment(diagonal_matrix([q] </span><span style=color:#fe8019>* </span><span style=color:#fdf4c1>m))</span><span>.T
</span><span>  lattice </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>basis.BKZ()
</span><span>
</span><span>  </span><span style=color:#fa5c4b>for </span><span>row </span><span style=color:#fa5c4b>in </span><span style=color:#fdf4c1>lattice.rows()</span><span>:
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>all</span><span style=color:#fdf4c1>(x </span><span style=color:#fe8019>in </span><span style=color:#fdf4c1>[</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>] </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>x </span><span style=color:#fa5c4b>in </span><span style=color:#fdf4c1>row)</span><span>:
</span><span>      </span><span style=color:#fa5c4b>return </span><span>row
</span></code></pre><p>to get the actual error e with signs. Now we have the actual e value, all we have to do is invert the equation $$ b= (A @ s + e) mod q $$ and solve for s<blockquote><p>note: we solve this by treating the equation to be in the finite field q, this allows us to use simple modular arithmatic properties to invert the equation.</blockquote><pre class=language-python data-lang=python style=background:#282828;color:#fdf4c1aa><code class=language-python data-lang=python><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>recover_secret</span><span>(</span><span style=color:#fdf4c1>A</span><span>, </span><span style=color:#fdf4c1>b</span><span>, </span><span style=color:#fdf4c1>e</span><span>, </span><span style=color:#fdf4c1>q</span><span>):
</span><span>  
</span><span>    A_mod  </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>Matrix(GF(q), A)
</span><span>    rhs    </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>vector(GF(q), (b </span><span style=color:#fe8019>- </span><span style=color:#fdf4c1>e))
</span><span>
</span><span>    s </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>A_mod.solve_right(rhs) </span><span style=font-style:italic;color:#928374>#solves for s
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span>[</span><span style=color:#fabd2f>int</span><span style=color:#fdf4c1>(x) </span><span style=color:#fe8019>% </span><span>q </span><span style=color:#fa5c4b>for </span><span>x </span><span style=color:#fa5c4b>in </span><span>s]
</span><span>
</span></code></pre><p>And thats it! its solved. We can call the get_flag function in the puzzle and give them the secret s we discovered. we are then returned the final flag. :)<blockquote><p>Code for writeup sourced from @ibrahim in GCTF discord server</blockquote><p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>