<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>JS Safe</title><meta content="JS Safe" name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/js_safe/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content="JS Safe" property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/js_safe/ property=twitter:url><meta content="JS Safe" property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/js_safe/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>js_safe</span></div><time datetime=2025-07-04>Published on: <span class=accent-data>2025-07-04</span></time><address rel=author>By <span class=accent-data> Arun Radhakrishnan, and exploiitm </span></address><h1>JS Safe</h1><h3 id=description>Description</h3><p>We’re given a website that is designed to store secrets. Secrets are xored with the correct flag and put into local storage, and can be unlocked by providing the flag as input to the unlock function. The flag is encrypted (simple rotation) and then heavily scrambled before being stored into the variable ‘pool’. When checking the flag, it is unencrypted and unscrambled characterwise and checked with the input characterwise.<p>All this happens on client side, no connection or request is made to server… so we can tamper with it.<h3 id=the-safety-valves>The Safety Valves</h3><ol><li>The first issue preventing us from tampering with the code comes from the instrument and instrument prototype functions. These functions associate some function calls with a price. The step value gets incremented by the price each time that particular function is run. So if we tamper the code (by say, maybe editing the render function), not enough function calls are made, and therefore the step value isn’t incremented properly.</ol><p>And if the step value isn’t incremented properly, we’ll have issues unscrambling the ‘pool’ during flag check (as shown in the code snippet below)<pre class=language-js data-lang=js style=background:#282828;color:#fdf4c1aa><code class=language-js data-lang=js><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#fe8019>!</span><span style=color:#fabd2f>window</span><span>.</span><span style=color:#fdf4c1>success</span><span>) {
</span><span>        </span><span style=color:#fdf4c1>j </span><span style=color:#fe8019>= </span><span>((</span><span style=color:#fdf4c1>iﾠ</span><span style=color:#fe8019>|| </span><span style=color:#d3869b>1</span><span>)</span><span style=color:#fe8019>* </span><span style=color:#d3869b>16807 </span><span style=color:#fe8019>+ </span><span style=color:#fabd2f>window</span><span>.</span><span style=color:#fdf4c1>step</span><span>) </span><span style=color:#fe8019>% </span><span style=color:#d3869b>2147483647</span><span>;
</span><span>        </span><span style=color:#fe8019>...
</span><span>    }
</span></code></pre><p>The only way around this is to not include or delete any function calls that might happen before the flag is fully checked. The silver lining, however, is that this only applies to certain function calls, not basic operations like string concatenation etc. (we’ll return to this fact in a moment)<ol start=2><li>Another issue with changing the code, is this line</ol><pre class=language-js data-lang=js style=background:#282828;color:#fdf4c1aa><code class=language-js data-lang=js><span style=color:#8ec07c>Function</span><span style=color:#b8bb26>`[0].step; if (window.step == 0 || check.toString().length !== 914) while(true) debugger; // Aﾠcooler wayﾠto eval```
</span></code></pre><p>This places a check on the function ‘check’ and ensures that it hasn’t been changed or messed around with. In theory, we would have to find some way out of this (maybe even delete this line somehow). But turns out, that the check is very simple. As long as the function length is 914, we have no issues. So we’ll just make sure that our tampered code remains 914 characters.<ol start=3><li>Another safety feature added is CSP (Content Securtiy Policy) in the meta tag at the start of the file. Usually this is a pretty solid security feature. They’ve mentioned two sha-256 hashes, and only those scripts which have those hash can run. But again, our code is entirely local, so we can literally just change the sha-256 hash in the csp to whatever the hash of our tampered code and then run that file locally.</ol><h3 id=the-exploit>The Exploit</h3><p>Keeping these three in mind, we will have try to make changes to the check function code. One of the main things we want to change is this:<pre class=language-js data-lang=js style=background:#282828;color:#fdf4c1aa><code class=language-js data-lang=js><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fdf4c1>flag</span><span>[</span><span style=color:#d3869b>0</span><span>] </span><span style=color:#fe8019>== </span><span style=color:#fdf4c1>pool</span><span>[</span><span style=color:#fdf4c1>j </span><span style=color:#fe8019>% </span><span style=color:#fdf4c1>pool</span><span>.</span><span style=color:#fabd2f>length</span><span>] </span><span style=color:#fe8019>&& </span><span>(</span><span style=color:#fabd2f>window</span><span>.</span><span style=color:#fdf4c1>step </span><span style=color:#fe8019>< </span><span style=color:#d3869b>1000000</span><span>))
</span></code></pre><p>We don’t know the flag, and we don’t want to guess. So this condition has to go.<p>A simple fix is to just replace it with<pre class=language-js data-lang=js style=background:#282828;color:#fdf4c1aa><code class=language-js data-lang=js><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#d3869b>1</span><span>)
</span></code></pre><p>One potential issue: maybe the code was designed such that only some iterations would satisfy the condition, but we will make an educated guess that it won’t be the case.<p>Now that our check function is running properly, we have to figure out how to get some info out of it. We could maybe print the j value in each iteration (but that might affect the step count), we could store each j value and print at end, or wait…<p>We could literally just store all the values of:<pre class=language-js data-lang=js style=background:#282828;color:#fdf4c1aa><code class=language-js data-lang=js><span style=color:#fdf4c1>pool</span><span>[</span><span style=color:#fdf4c1>j </span><span style=color:#fe8019>% </span><span style=color:#fdf4c1>pool</span><span>.</span><span style=color:#fabd2f>length</span><span>]
</span></code></pre><p>which would be all the characters of the flag in order. And since accessing array elements and appending to string don’t seem to modify the function, we should be good to go.<p>So we make the following changes<pre class=language-diff data-lang=diff style=background:#282828;color:#fdf4c1aa><code class=language-diff data-lang=diff><span>window.check // Checks password
</span><span> = function() {
</span><span>    Function`[0].step; if (window.step == 0 || check.toString().length !== 914) while(true) debugger; // Aﾠcooler wayﾠto eval```
</span><span>    // Functionﾠuntampered,ﾠproceed to 'decryption` & check
</span><span>    try {
</span><span>    window.step = 0;
</span><span>    [0].step;
</span><span>    const flag = (window.flag||'').split('');  
</span><span style=color:#fa5c4b>- let iﾠ= 1337, j = 0;
</span><span style=color:#8ec07c>+ let iﾠ= 1337, j = 0, z = '';
</span><span>    let pool =ﾠ`?o>\`Wn0o0U0N?05o0ps}q0|mt\`ne\`us&400_pn0ss_mph_0\`5`;
</span><span>    pool = r(pool).split('');
</span><span>    const double = Function.call`window.stepﾠ*=ﾠ2`;ﾠ// To the debugger,ﾠthis isﾠinvisible
</span><span>    while (!window.success) {
</span><span>        j = ((iﾠ|| 1)* 16807 + window.step) % 2147483647;
</span><span style=color:#fa5c4b>-        if (flag[0] == pool[j % pool.length] && (window.step < 1000000)) {
</span><span style=color:#8ec07c>+        if (1) { z += pool[ j % pool.length ];
</span><span>            iﾠ= j;
</span><span>            flag.shift();
</span><span>            pool.splice(j % pool.length, 1);
</span><span>            renderFrame();
</span><span>            double();
</span><span>            if (!pool.length&&!flag.length) window.success = true;
</span><span>        }
</span><span>    }
</span><span style=color:#8ec07c>+    console.log(z);
</span><span>    } catch(e) {}
</span><span>}
</span></code></pre><p>Ensure to modify the spacing etc. so that the length of the function is the same. And also change the second sha256 hash in the csp protection to be the hash of our modified code.<p>And voila, the exploit is ready. All we have to do is run the code, open console (use the preserve log setting, otherwise the output will get deleted), type in “anti(debug)” and then “unlock(“CTF{…}”)“ (… can be anything really) and you get your output (you might have to scroll up a bit to find it).<p>1M_4_C7F_p14y32_4N71_d38U9_721cK5_d0n7_w02K_0n_m3<p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>