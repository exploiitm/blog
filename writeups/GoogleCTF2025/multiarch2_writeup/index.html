<!doctype html><html lang=en><head><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:true,processEnvironments:true}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>MultiArch2</title><meta content=MultiArch2 name=title><meta content=exploiitm name=author><meta content="Official blog of Cybersecurity Club, IIT Madras" name=description><meta content=website property=og:type><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/multiarch2_writeup/ property=og:url><meta content="exploiitm blog" property=og:site_name><meta content=MultiArch2 property=og:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=og:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/multiarch2_writeup/ property=twitter:url><meta content=MultiArch2 property=twitter:title><meta content="Official blog of Cybersecurity Club, IIT Madras" property=twitter:description><meta content=https://exploiitm.github.io/blog/favicon.ico property=twitter:image><link href=https://exploiitm.github.io/blog/writeups/GoogleCTF2025/multiarch2_writeup/ rel=canonical><link rel="shortcut icon" href=https://exploiitm.github.io/blog/favicon.ico type=image/x-icon><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://exploiitm.github.io/blog/css/style.css rel=stylesheet><script defer src=https://exploiitm.github.io/blog/js/script.js></script><body><header><nav id=nav-bar><a href=https://exploiitm.github.io/> home </a><a href=/blog> blog </a><a href=/blog/writeups> writeups </a><a href=/blog/about> about </a><a href=/blog/contacts> contact </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://exploiitm.github.io/blog/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://exploiitm.github.io/blog/click.ogg type=audio/ogg></audio></div></nav></header><main><div><a href=..>..</a>/<span class=accent-data>multiarch2_writeup</span></div><time datetime=2025-09-03>Published on: <span class=accent-data>2025-09-03</span></time><address rel=author>By <span class=accent-data> Vrishab, and exploiitm </span></address><h1>MultiArch2</h1><h2 id=summary-of-the-exploit>Summary of the Exploit</h2><p>This challenge is built around exploiting a custom VM built with two separate instruction sets (stack‑based and register‑based)<p>Inside the register‑based instruction set, a key bug in the XOR instruction lets us write outside the space reserved for registers. This allows us to trick the VM so that a normal VM memory address (<code>0xA000</code>) actually points to the VM’s own internal state struct <code>masm_struct</code>. We can leak useful memory addresses from inside the VM, overwrite the VM function pointer <code>get_flag</code> to make it point to our shellcode and thereafter trigger that function pointer and get code execution<hr><h2 id=vm-setup>VM Setup</h2><p>When the VM runs, it loads a custom file format called <code>.masm</code>, each of which consists of several regions that get mapped when the VM starts:<ul><li><strong>Code segment</strong>: the instructions the VM runs<li><strong>Data segment</strong>: attacker‑controlled, marked as rwx i.e. read, write, execute<li><strong>Stack segment</strong>: where stack‑arch instructions operate<li><strong>Arch table</strong>: tells the VM about whether each instruction runs in stack mode or register mode</ul><p>This design means we can place custom shellcode directly into the data segment, then aim to transfer execution there<hr><h3 id=vm-state-masm-struct>VM State: <code>masm_struct</code></h3><p>Internally, the VM maintains everything in a large structure <code>masm_struct</code>. It contains:<ul><li>pointers to the code, data, and arch table in memory<li>four general registers, a stack pointer, and program counter<li>function pointer called <strong><code>get_flag</code></strong> at offset <code>0x28</code>, which we want to hijack<li>metadata about heap allocations (<code>heap_array</code>)</ul><hr><h2 id=vulnerability-out-of-bounds-xor>Vulnerability: Out‑of‑Bounds XOR</h2><p>Inside the register instruction set, there is an instruction <code>0x41 &LTidx> &LTimm32>` is supposed to do `registers[idx] ^= imm32</code><p>The issue is that the VM never checks whether <code>idx</code> is a valid register index. By giving a large enough index, we can XOR into memory well beyond the register array, which overlaps with the <code>heap_array</code>. By crafting values, we can change one of the heap metadata pointers stored there<hr><h2 id=exploit>Exploit</h2><h3 id=step-1-making-heap-allocation>Step 1 – Making Heap Allocation</h3><p>Using stack‑arch syscall <code>6</code>, we allocate a heap block. The VM maps it at virtual address <code>0xA000</code>, and internally records the mapping in <code>heap_array[0]</code> - <code>{ real_heap_ptr, 0xA000 }</code><hr><h3 id=step-2-corrupting-heap-metadata>Step 2 – Corrupting Heap Metadata</h3><p>We switch to register‑arch and use the buggy XOR on a big index so we land inside and overwrite <code>heap_array.real_ptr</code>. Instead of pointing to the real heap, we flip it so it points to the <code>masm_struct</code> itself. So now whenever we use <code>0xA000</code>, we are actually accessing the VM’s internal state struct<hr><h3 id=step-3-leaking-information>Step 3 – Leaking Information</h3><p>We use stack‑arch syscall 2 (fwrite) to dump memory starting from <code>0xA000</code>. But <code>0xA000</code> maps <code>masm_struct</code>, so this gives us a leak of critical VM internals i.e. the real memory address of the <strong>data segment</strong> (<code>seg1</code>), which we control. This is the RWX memory where shellcode is already stored<hr><h3 id=step-4-overwriting-the-get-flag-pointer>Step 4 – Overwriting the get_flag Pointer</h3><p>We now use register‑arch syscall 1 (fread) to write into VM memory (at <code>0xA000 + 0x28</code>, which resolves to <code>&masm_struct->get_flag</code> due to our corruption). We overwrite that with the leaked <code>seg1</code> address. Now whenever the VM tries to call <code>get_flag</code>, it will instead jump to our data segment where we’ve placed our shellcode<hr><h3 id=step-5-running-shellcode>Step 5 – Running Shellcode</h3><p>Finally, we use stack‑arch syscall 5, which usually calls <code>get_flag</code>. But it now points to our RWX data segment, so the syscall runs our injected shellcode<hr><h2 id=overall-exploit-flow>Overall Exploit Flow</h2><ol><li>Allocate heap chunk at <code>0xA000</code><li>Use buggy XOR to poison heap_array so <code>0xA000</code> maps to <code>masm_struct</code><li>Dump (<code>fwrite</code>) <code>masm_struct</code> and find seg1 address<li>Overwrite <code>get_flag</code> with that address<li>Call <code>syscall 5</code> → shellcode runs</ol><p><strong>Credits</strong>: 堇姬 Naup (https://naup.mygo.tw/2025/07/05/2025-Google-CTF-writeup/)<p class=tags-data></main><footer><hr><div class=footContainer><div class=footLeft><p>Licensed under <a rel="noopener noreferrer" href=https://fr.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a><br></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData href=https://exploiitm.github.io/blog/atom.xml target=_blank>RSS</a></div></div></footer>